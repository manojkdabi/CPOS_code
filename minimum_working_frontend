<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CP-OS v1.0 DSS (Lite)</title>

  <style>
    :root {
      --bg: #f5f6fb;
      --surface: #ffffff;
      --surface2: #f2f3f7;
      --surface3: #e9edf5;
      --text: #1f2937;
      --muted: #5b6472;
      --muted2: #7a8494;
      --stroke: rgba(31, 41, 55, 0.14);
      --stroke2: rgba(31, 41, 55, 0.10);
      --divider: rgba(31, 41, 55, 0.08);
      --brandBlue1: #2f6fb5;
      --brandBlue2: #3c83c9;
      --brandField: #8fbf78;
      --primary: #2f6fb5;
      --primary2: #245ea6;
      --lemon: #f4d06f;
      --ok: #3a8f4b;
      --warn: #e6a83a;
      --recommended: #3c64b1;
      --conditional: #d77a1f;
      --shadow: 0 10px 24px rgba(28, 38, 63, 0.16);
      --shadow2: 0 16px 40px rgba(28, 38, 63, 0.18);
      --radius: 16px;
      --radius2: 22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue";
    }

    * { box-sizing: border-box }

    body {
      margin: 0;
      font-family: var(--sans);
      background: var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
    }

    .app { max-width: 1200px; margin: 0 auto; padding: 20px 18px 28px }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 16px;
      padding: 12px 12px;
      border-radius: var(--radius2);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.00)),
                  linear-gradient(90deg, var(--brandBlue2), var(--brandField));
      color: #fff;
      box-shadow: var(--shadow2);
      border: 1px solid rgba(255,255,255,0.20);
    }

    .brand { display: flex; align-items: center; gap: 12px }

    .logo {
      width: 44px; height: 44px;
      border-radius: 14px;
      background: linear-gradient(135deg, rgba(47,111,181,0.95), rgba(143,191,120,0.95));
      box-shadow: 0 12px 30px rgba(28,38,63,0.22);
      position: relative;
    }

    .logo:after {
      content: "";
      position: absolute;
      inset: 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.35);
      border: 1px solid rgba(255,255,255,0.35);
    }

    .titleblock .h1 { font-size: 18px; font-weight: 900; margin: 0 }

    .status-pill {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,0.22);
      border: 1px solid rgba(255,255,255,0.28);
      color: #fff;
      max-width: 520px;
    }

    .dot {
      width: 9px; height: 9px;
      border-radius: 50%;
      background: rgba(255,255,255,0.65)
    }
    .dot.ok { background: var(--ok) }
    .dot.bad { background: #ef4444 }

    .status-text {
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: rgba(255,255,255,0.95);
    }

    .tabs {
      display: flex;
      gap: 10px;
      padding: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.70);
      border: 1px solid var(--stroke2);
      margin-bottom: 16px;
      overflow: auto;
      box-shadow: var(--shadow);
    }

    .tab {
      flex: 1;
      min-width: 260px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      cursor: pointer;
      border: 1px solid transparent;
      background: rgba(255,255,255,0.85);
      color: var(--text);
      transition: all 120ms ease;
      user-select: none;
    }
    .tab:hover { background: rgba(255,255,255,0.95) }
    .tab.active {
      background: linear-gradient(180deg, rgba(244,208,111,0.60), rgba(255,255,255,0.92));
      border-color: rgba(244,208,111,0.90);
      box-shadow: 0 10px 22px rgba(28,38,63,0.14);
    }

    .badgeNum {
      width: 28px; height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      font-weight: 950;
      font-size: 12px;
      background: rgba(31,41,55,0.08);
      border: 1px solid rgba(31,41,55,0.12);
    }
    .tab.active .badgeNum {
      background: rgba(244,208,111,0.65);
      border-color: rgba(244,208,111,0.95)
    }

    .tabText { display: flex; flex-direction: column; gap: 2px }
    .tab .label { font-weight: 900; font-size: 13px }
    .tab .desc { font-size: 12px; color: var(--muted) }

    .grid { display: grid; grid-template-columns: 1.25fr 0.75fr; gap: 14px }
    @media (max-width:980px) { .grid { grid-template-columns: 1fr } }

    .card {
      background: var(--surface);
      border: 1px solid var(--stroke);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .cardHeader {
      padding: 14px 16px;
      border-bottom: 1px solid var(--divider);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: linear-gradient(180deg, rgba(233,237,245,0.75), rgba(255,255,255,0));
    }

    .cardHeader .h2 {
      margin: 0;
      font-size: 13px;
      letter-spacing: 0.35px;
      font-weight: 950;
      text-transform: uppercase;
      color: var(--text);
    }

    .cardHeader .hint { font-size: 12px; color: var(--muted) }
    .cardBody { padding: 14px 16px 16px }

    .btnRow { display: flex; flex-wrap: wrap; gap: 10px }

    .btn {
      border-radius: 999px;
      padding: 10px 14px;
      border: 1px solid var(--stroke2);
      background: rgba(233,237,245,0.85);
      color: var(--text);
      cursor: pointer;
      font-weight: 900;
      font-size: 13px;
      transition: all 120ms ease;
      user-select: none;
    }
    .btn:hover { background: rgba(233,237,245,1) }
    .btn.primary {
      background: linear-gradient(180deg, rgba(47,111,181,0.95), rgba(36,94,166,0.95));
      border-color: rgba(36,94,166,0.85);
      color: #fff;
    }
    .btn.ghost { background: rgba(255,255,255,0.90) }
    .btn:disabled { opacity: 0.55; cursor: not-allowed }

    .formGrid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px }
    @media (max-width:980px) { .formGrid { grid-template-columns: 1fr } }

    .field {
      background: rgba(255,255,255,0.92);
      border: 1px solid var(--stroke2);
      border-radius: 14px;
      padding: 10px 12px;
    }

    .field label {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .field label .cat {
      font-size: 11px;
      color: rgb(35,95,55);
      border: 1px solid rgb(160,215,170);
      padding: 2px 8px;
      border-radius: 999px;
      background: rgb(220,245,225);
      white-space: nowrap;
      font-weight: 800;
    }

    .field > label > span:first-child {
      font-weight: 800;
      color: rgb(128,0,32);
    }

    input, textarea, select {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,0.95);
      color: var(--text);
      padding: 10px 10px;
      font-size: 13px;
      outline: none;
    }
    textarea { min-height: 84px; resize: vertical }

    .small { font-size: 13px; color: var(--muted); line-height: 1.55 }

    .mutedBox {
      border: 1px dashed rgba(47,111,181,0.28);
      border-radius: 14px;
      padding: 12px 12px;
      background: linear-gradient(180deg, rgba(47,111,181,0.10), rgba(255,255,255,0.92));
      color: #111827;
      font-size: 13px;
      line-height: 1.6;
      white-space: pre-line;
    }

    .chips { display: flex; flex-wrap: wrap; gap: 8px }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 11px;
      border-radius: 999px;
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,0.85);
      font-size: 13px;
      color: var(--text);
    }
    .chip .k { font-family: var(--mono); font-size: 11.5px; color: var(--muted2) }

    .pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 7px 11px;
      font-weight: 950;
      font-size: 12px;
      letter-spacing: 0.25px;
      border: 1px solid var(--stroke2);
      background: rgba(233,237,245,0.85);
      text-transform: uppercase;
      color: var(--text);
    }
    .pill.ok { background: rgba(58,143,75,0.18); border-color: rgba(58,143,75,0.35); color: #1f5f2f }
    .pill.warn { background: rgba(215,122,31,0.18); border-color: rgba(215,122,31,0.35); color: #7a3f0a }
    .pill.bad { background: rgba(239,68,68,0.10); border-color: rgba(239,68,68,0.35); color: #991b1b }
    .pill.blue { background: rgba(60,100,177,0.18); border-color: rgba(60,100,177,0.35); color: #25408c }

    .pathGrid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px }
    @media (max-width:980px) { .pathGrid { grid-template-columns: 1fr } }

    .pathCard {
      position: relative;
      border: 1px solid rgba(31,41,55,0.10);
      box-shadow: 0 10px 24px rgba(28,38,63,0.10);
      overflow: hidden;
      border-radius: 18px;
      padding: 14px;
      background: linear-gradient(180deg, rgba(47,111,181,0.07), rgba(255,255,255,1) 60%);
    }
    .pathCard::before {
      content: "";
      position: absolute;
      left: 0; top: 0; bottom: 0;
      width: 6px;
      border-radius: 18px 0 0 18px;
      background: rgba(47,111,181,0.55);
    }
    .pathCard.path-rp { background: linear-gradient(180deg, rgba(58,143,75,0.10), rgba(255,255,255,1) 60%) }
    .pathCard.path-rp::before { background: rgba(58,143,75,0.60) }
    .pathCard.path-awd { background: linear-gradient(180deg, rgba(215,122,31,0.10), rgba(255,255,255,1) 60%) }
    .pathCard.path-awd::before { background: rgba(215,122,31,0.60) }
    .pathCard.path-bio { background: linear-gradient(180deg, rgba(60,100,177,0.10), rgba(255,255,255,1) 60%) }
    .pathCard.path-bio::before { background: rgba(60,100,177,0.60) }
    .pathCard.path-erw { background: linear-gradient(180deg, rgba(15,118,110,0.10), rgba(255,255,255,1) 60%) }
    .pathCard.path-erw::before { background: rgba(15,118,110,0.60) }

    .pathTop { display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; margin-bottom: 12px }
    .pathName { font-weight: 1000; font-size: 15px; margin: 0; color: var(--text) }
    .pathMeta { display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end }
    .list { margin: 8px 0 0; padding-left: 16px; color: rgba(31,41,55,0.78); font-size: 13px; line-height: 1.6 }

    .panel { display: none }
    .panel.active { display: block }

    .foot { margin-top: 14px; font-size: 12px; color: rgba(31,41,55,0.45); text-align: center }

    .warning-box {
      background: rgba(230,168,58,0.1);
      border: 1px solid var(--warn);
      border-radius: 12px;
      padding: 12px;
      margin: 10px 0;
    }
    .probe-box {
      background: linear-gradient(135deg, #e3f2fd, #bbdefb);
      border: 2px solid #2196F3;
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>
  <div class="app">
    <!-- Top Bar -->
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div class="titleblock">
          <div class="h1">Soil Carbon Pathway-Optimization System (SCP-OS) v1.0</div>
        </div>
      </div>
      <div class="status-pill">
        <div id="statusDot" class="dot"></div>
        <div id="statusText" class="status-text">Loading…</div>
      </div>
    </div>

    <!-- Tabs -->
    <div class="tabs" role="tablist">
      <button class="tab active" data-step="0" onclick="goStep(0)">
        <span class="badgeNum">0</span>
        <span class="tabText">
          <span class="label">Adaptive Questionnaire (Fast Setup)</span>
          <span class="desc">Auto-fill Step 1 inputs</span>
        </span>
      </button>
      <button class="tab" data-step="1" onclick="goStep(1)">
        <span class="badgeNum">1</span>
        <span class="tabText">
          <span class="label">Land and Management context</span>
          <span class="desc">Enter values (auto-classify)</span>
        </span>
      </button>
      <button class="tab" data-step="2" onclick="goStep(2)">
        <span class="badgeNum">2</span>
        <span class="tabText">
          <span class="label">Carbon Opportunity Analysis</span>
          <span class="desc">Scores • Eligibility • MRV tier</span>
        </span>
      </button>
      <button class="tab" data-step="3" onclick="goStep(3)">
        <span class="badgeNum">3</span>
        <span class="tabText">
          <span class="label">Decision Summary</span>
          <span class="desc">Stack + Save</span>
        </span>
      </button>
    </div>

    <!-- Language Selector -->
    <div style="margin-bottom:20px;padding:12px;background:rgba(255,255,255,0.95);border-radius:12px;border:1px solid var(--stroke2)">
      <label style="font-weight:600;margin-right:12px;font-size:14px">Language / भाषा:</label>
      <label style="margin-right:16px;cursor:pointer">
        <input type="radio" name="language" value="EN" id="langEN" checked> English
      </label>
      <label style="cursor:pointer">
        <input type="radio" name="language" value="HI" id="langHI"> हिन्दी (Hindi)
      </label>
    </div>

    <!-- Panel 0: Questionnaire -->
    <div id="panel0" class="panel active">
      <div class="grid">
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Adaptive Questionnaire</h3>
            <div class="hint">about 50 Q - Fast setup - Auto-fills Step 1</div>
          </div>
          <div class="cardBody">
            <div class="small" id="qProgress">Answered 0 / target 20 (0%)</div>
            <div style="margin-top:10px" class="mutedBox" id="qQuestionText">Click Start to begin the questionnaire.</div>
            <div id="qHelpText" class="small" style="margin-top:8px"></div>
            <div id="qAnswerBox" style="margin-top:10px"></div>
            <div id="qNavStatus" class="small" style="margin-top:8px"></div>
            <div style="margin-top:12px" class="btnRow">
              <button class="btn ghost" id="btnQStart" onclick="qStart()" disabled>Start</button>
              <button class="btn ghost" id="btnQBack" onclick="qBack()" disabled>Back</button>
              <button class="btn ghost" id="btnQSkip" onclick="qSkip()" disabled>Skip</button>
              <button class="btn primary" id="btnQNext" onclick="qNext()" disabled>Next</button>
              <button class="btn primary" id="btnQFinish" onclick="qFinish()" disabled>Finish</button>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Derived Signals + Auto-filled Factors</h3>
            <div class="hint">Questionnaire explainability</div>
          </div>
          <div class="cardBody">
            <div id="qDerivedBox" class="mutedBox">Signals and auto-filled factors will appear here.</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Panel 1: Inputs -->
    <div id="panel1" class="panel">
      <div class="grid">
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Inputs</h3>
            <div class="hint">Grouped by Factor_Category • Select class for each factor</div>
          </div>
          <div class="cardBody">
            <div class="formGrid" id="factorForm"></div>
            <div id="evalGate" style="margin-top:12px;">
              <div class="btnRow">
                <button class="btn ghost" onclick="clearSelections()">Clear</button>
                <button class="btn primary" id="btnEvaluate" onclick="evaluateAndGo()" disabled>Evaluate →</button>
              </div>
              <div id="evalGateHint" class="small" style="margin-top:8px"></div>
            </div>
            <div style="margin-top:10px" class="small" id="selectionHint">
              Tip: Enter any soil + climate + management values you have. You can evaluate even with partial inputs.
            </div>
          </div>
        </div>
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Explainability</h3>
            <div class="hint">Weights × desirability + Pathway_context</div>
          </div>
          <div class="cardBody">
            <div id="notesBox" class="mutedBox">Enter values to view class, desirability, and pathway context here.</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Panel 2: Results -->
    <div id="panel2" class="panel">
      <div class="grid">
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Pathway Screening</h3>
            <div class="hint">Computed from Lite tables</div>
          </div>
          <div class="cardBody">
            <div id="screeningGrid" class="pathGrid"></div>
            <div style="margin-top:12px" class="btnRow">
              <button class="btn ghost" onclick="goStep(1)">← Back</button>
              <button class="btn primary" onclick="goStep(3)">Decision Summary →</button>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Current Inputs</h3>
            <div class="hint">Observed_Value + classified Class_Label</div>
          </div>
          <div class="cardBody">
            <div id="selectionRecap" class="chips"></div>
            <div style="margin-top:12px" class="mutedBox" id="mrvStrip">MRV focus strip will appear after evaluation.</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Panel 3: Summary -->
    <div id="panel3" class="panel">
      <div class="grid">
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Decision Summary</h3>
            <div class="hint">Recommended stack + key cautions</div>
          </div>
          <div class="cardBody">
            <div id="headlineBox" class="mutedBox">Evaluate at least one input to generate a decision summary.</div>
            <div class="small" style="margin-bottom:8px;color:var(--muted)"><b>Recommended</b></div>
            <div id="recStack" class="chips" style="margin-bottom:12px"></div>
            <div class="small" style="margin-bottom:8px;color:var(--muted)"><b>Conditional</b></div>
            <div id="condStack" class="chips" style="margin-bottom:12px"></div>
            <div class="small" style="margin-bottom:8px;color:var(--muted)"><b>Excluded</b></div>
            <div id="exclStack" class="chips" style="margin-bottom:8px"></div>
            <div style="margin-top:12px" class="btnRow">
              <button class="btn ghost" onclick="goStep(2)">← Back</button>
              <button class="btn primary" onclick="saveAssessment()">Save Assessment</button>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Save Assessment</h3>
            <div class="hint">Optional metadata</div>
          </div>
          <div class="cardBody">
            <div class="formGrid">
              <div class="field">
                <label>Client_ID <span class="cat">meta</span></label>
                <input id="metaClientId" placeholder="Default">
              </div>
              <div class="field">
                <label>Site_ID <span class="cat">meta</span></label>
                <input id="metaSiteId" placeholder="SITE-001">
              </div>
              <div class="field">
                <label>Site_Name <span class="cat">meta</span></label>
                <input id="metaSiteName" placeholder="Village / Farm / Plot">
              </div>
              <div class="field">
                <label>Crop_System <span class="cat">meta</span></label>
                <input id="metaCropSystem" placeholder="Rice paddy / Upland cereal">
              </div>
              <div class="field" style="grid-column:1/-1">
                <label>Notes <span class="cat">meta</span></label>
                <textarea id="metaNotes" placeholder="Any assumptions, site notes…"></textarea>
              </div>
            </div>
            <div id="saveStatus" style="margin-top:10px" class="small"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="foot">CP-OS v1.0 • CPOS-Lite (Full Features)</div>
  </div>

  <script>
    // ============================================================
    // CPOS-LITE FRONTEND - COMPLETE VERSION WITH ALL FEATURES
    // ============================================================

    // Global state object
    const CPOSL = {
      language: 'EN',
      PATHWAYS: ['RP-SOC', 'AWD-CH₄', 'BIOCHAR', 'ERW'],
      data: { bounds: [], desirability: [], weights: [] },
      idx: {
        boundsByVar: new Map(),
        desirIdx: new Map(),
        wIdx: new Map()
      },
      selections: {},
      lastResults: null,
      q: {
        available: false,
        bank: [],
        options: [],
        derivationRules: [],
        routingRules: [],
        signalToLiteMap: [],
        idx: {
          qBankById: new Map(),
          qOptionsByQ: new Map(),
          qDerivByWhenQ: new Map(),
          qRoutesByCurrentQ: new Map(),
          qSignalMapByKey: new Map(),
          startQuestions: []
        }
      },
      qState: {
        mode: 'BASIC',
        sessionId: '',
        answered: {},
        signals: {},
        queue: [],
        current: null,
        history: [],
        answeredCount: 0,
        minTarget: 5,
        maxCap: 50,
        stop: false,
        probeCount: 0,
        pendingProbe: null,
        pendingWarning: null
      }
    };

    // ============================================================
    // UTILITIES
    // ============================================================
    function setStatus(ok, msg) {
      const dot = document.getElementById('statusDot');
      const text = document.getElementById('statusText');
      if (dot) {
        dot.classList.remove('ok', 'bad');
        dot.classList.add(ok ? 'ok' : 'bad');
      }
      if (text) text.textContent = msg || (ok ? 'Ready' : 'Error');
    }

    function goStep(n) {
      document.querySelectorAll('.tab').forEach(function(el) {
        var isActive = Number(el.dataset.step) === n;
        el.classList.toggle('active', isActive);
      });
      for (var i = 0; i <= 3; i++) {
        var panel = document.getElementById('panel' + i);
        if (panel) panel.classList.toggle('active', i === n);
      }
    }

    function escapeHtml(s) {
      return String(s == null ? '' : s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    }

    function toNum(v) {
      if (v == null) return null;
      var n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function toBool(v) {
      if (typeof v === 'boolean') return v;
      var s = String(v || '').trim().toLowerCase();
      return s === 'true' || s === '1' || s === 'yes';
    }

    function normKey(s) {
      return String(s == null ? '' : s).trim().toLowerCase().replace(/[^a-z0-9]/g, '');
    }

    function getField(row, keys, fallback) {
      if (!row || typeof row !== 'object') return fallback !== undefined ? fallback : '';
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        if (row[k] !== undefined && row[k] !== null && String(row[k]).trim() !== '') {
          return row[k];
        }
      }
      return fallback !== undefined ? fallback : '';
    }

    // ============================================================
    // CONSISTENCY RULES - Validate answer coherence
    // ============================================================
    var CONSISTENCY_RULES = [
      {
        id: 'RULE_SOIL_01',
        name: 'Drainage-Texture Contradiction',
        check: function(signals) {
          var drainage = signals['DRAINAGE'] ? signals['DRAINAGE'].value : null;
          var texture = signals['TEXTURE'] ? signals['TEXTURE'].value : null;
          
          if ((drainage === 'POOR' || drainage === 'VERYPOOR') && 
              (texture === 'SANDY' || texture === 'LIGHTSANDY')) {
            return {
              valid: false,
              severity: 'HIGH',
              message: 'Sandy soils typically drain quickly. If water stays for 2-3 days, your soil likely has some clay content.',
              conflictingQuestions: ['Q_S015', 'Q_S008']
            };
          }
          return { valid: true };
        }
      },
      {
        id: 'RULE_SOIL_02',
        name: 'Compaction-Tillage Contradiction',
        check: function(signals) {
          var compaction = signals['COMPACTION'] ? signals['COMPACTION'].value : null;
          var tillage = signals['TILLAGE'] ? signals['TILLAGE'].value : null;
          
          if (compaction === 'HIGH' && tillage === 'ZEROTILL') {
            return {
              valid: false,
              severity: 'MEDIUM',
              message: 'Zero-till practices can initially cause surface compaction, but after 2-3 years it typically improves.',
              conflictingQuestions: ['Q_M021', 'Q_M009']
            };
          }
          return { valid: true };
        }
      },
      {
        id: 'RULE_NUMERIC_01',
        name: 'SOC Physical Bounds',
        check: function(signals) {
          var socSignal = signals['SOC_MEASURED'];
          var socValue = socSignal ? parseFloat(socSignal.value) : null;
          
          if (socValue && socValue > 10) {
            return {
              valid: false,
              severity: 'HIGH',
              message: 'Soil organic carbon above 10% is rare in mineral soils. Please verify the value.',
              conflictingQuestions: ['Q_S003']
            };
          }
          return { valid: true };
        }
      },
      {
        id: 'RULE_CROP_01',
        name: 'Rice-Rainfed Contradiction',
        check: function(signals) {
          var hasCrop = function(cropName) {
            return Object.keys(signals).some(function(k) {
              return k.indexOf('CROP') >= 0 && signals[k].value && 
                     String(signals[k].value).toUpperCase().indexOf(cropName) >= 0;
            });
          };
          
          var irrigation = signals['IRRIGATION'] ? signals['IRRIGATION'].value : null;
          
          if (hasCrop('RICE') && irrigation === 'NONE') {
            return {
              valid: false,
              severity: 'MEDIUM',
              message: 'Rice usually needs consistent water. Are you growing upland/aerobic rice, or is your area naturally flooded during monsoon?',
              conflictingQuestions: ['Q_A1', 'Q_M015']
            };
          }
          return { valid: true };
        }
      },
      {
        id: 'RULE_MGT_01',
        name: 'High Nitrogen - Low Yield Contradiction',
        check: function(signals) {
          var nRate = toNum(signals['NITROGEN_RATE'] ? signals['NITROGEN_RATE'].value : null);
          var yieldVal = toNum(signals['CROP_YIELD'] ? signals['CROP_YIELD'].value : null);
          var crop = signals['CROP'] ? signals['CROP'].value : null;
          
          if (nRate && nRate > 200 && yieldVal && yieldVal < 3 && 
              (crop === 'RICE' || crop === 'WHEAT' || crop === 'MAIZE')) {
            return {
              valid: false,
              severity: 'HIGH',
              message: 'High nitrogen (' + nRate + ' kg/ha) with low yield (' + yieldVal + ' t/ha) suggests inefficiency. Please verify.',
              conflictingQuestions: ['Q_M019', 'Q_A003']
            };
          }
          return { valid: true };
        }
      }
    ];

    function checkAnswerConsistency() {
      var violations = [];
      
      CONSISTENCY_RULES.forEach(function(rule) {
        try {
          var result = rule.check(CPOSL.qState.signals);
          if (!result.valid) {
            violations.push({
              ruleId: rule.id,
              ruleName: rule.name,
              severity: result.severity,
              message: result.message,
              conflictingQuestions: result.conflictingQuestions || []
            });
          }
        } catch (err) {
          console.warn('[Consistency] Rule ' + rule.id + ' failed:', err);
        }
      });
      
      return violations;
    }

    function showConsistencyWarning(violation) {
      var lang = CPOSL.language;
      var warningHtml = 
        '<div class="warning-box">' +
        '<div style="display:flex;gap:10px;align-items:flex-start">' +
        '<span style="font-size:24px">⚠️</span>' +
        '<div style="flex:1">' +
        '<div style="font-weight:700;margin-bottom:6px;color:var(--warn)">' + 
        (lang === 'HI' ? 'त्वरित जाँच' : 'Quick Check') + '</div>' +
        '<div style="font-size:13px;line-height:1.5;margin-bottom:10px">' + 
        escapeHtml(violation.message) + '</div>' +
        '<div style="display:flex;gap:8px;flex-wrap:wrap">' +
        '<button class="btn ghost" onclick="reviewConflict(\'' + violation.ruleId + '\')">' +
        (lang === 'HI' ? 'पिछले उत्तर देखें' : 'Review Previous Answers') + '</button>' +
        '<button class="btn primary" onclick="continueAnyway()">' +
        (lang === 'HI' ? 'फिर भी जारी रखें' : 'Continue Anyway') + '</button>' +
        '</div></div></div></div>';
      
      document.getElementById('qNavStatus').innerHTML = warningHtml;
      CPOSL.qState.pendingWarning = violation;
    }

    function reviewConflict(ruleId) {
      var violation = CPOSL.qState.pendingWarning;
      if (violation && violation.conflictingQuestions && violation.conflictingQuestions.length > 0) {
        alert('Conflicting answers from questions: ' + violation.conflictingQuestions.join(', '));
      }
      document.getElementById('qNavStatus').textContent = 'Review your answers, then click Next.';
      CPOSL.qState.pendingWarning = null;
    }

    function continueAnyway() {
      var violation = CPOSL.qState.pendingWarning;
      if (violation && violation.conflictingQuestions) {
        violation.conflictingQuestions.forEach(function(qid) {
          var ans = CPOSL.qState.answered[qid];
          if (ans && ans.derivedSignals) {
            Object.keys(ans.derivedSignals).forEach(function(sigKey) {
              if (CPOSL.qState.signals[sigKey]) {
                CPOSL.qState.signals[sigKey].confidence *= 0.8;
                CPOSL.qState.signals[sigKey].hasConflict = true;
              }
            });
          }
        });
      }
      document.getElementById('qNavStatus').textContent = '';
      CPOSL.qState.pendingWarning = null;
      proceedToNextQuestion();
    }

    // ============================================================
    // PROBE SYSTEM - Follow-up clarification questions
    // ============================================================
    var PROBE_TEMPLATES = {
      'RESIDUE_USE_CONFLICT': {
        text: 'You mentioned both removing and retaining residue. Can you estimate what % stays in field?',
        text_hi: 'आपने अवशेष को हटाने और रखने दोनों का उल्लेख किया। कितना % खेत में रहता है?',
        answerType: 'single_select',
        options: ['0-25%', '25-50%', '50-75%', '75-100%'],
        confidenceBoost: 0.3
      },
      'ZERO_TILL_CONFIRMATION': {
        text: 'You said zero-till, but mentioned multiple passes. Do you use a direct seeding machine?',
        text_hi: 'आपने जीरो-टिल कहा, लेकिन कई बार जुताई का उल्लेख किया। क्या आप डायरेक्ट सीडिंग मशीन का उपयोग करते हैं?',
        answerType: 'single_select',
        options: ['True zero-till with direct seeding', 'Very light surface scratching only', 'Some shallow cultivation before planting'],
        confidenceBoost: 0.4
      },
      'IRRIGATION_CLARIFY': {
        text: 'You said rainfed, but mentioned irrigation events. Are those supplemental irrigations?',
        text_hi: 'आपने वर्षा आधारित कहा, लेकिन सिंचाई का उल्लेख किया। क्या ये पूरक सिंचाई हैं?',
        answerType: 'single_select',
        options: ['Only rainwater - no irrigation', 'Life-saving irrigation 1-2 times', 'Regular supplemental irrigation'],
        confidenceBoost: 0.35
      },
      'NITROGEN_RATE_VERIFY': {
        text: 'The nitrogen rate seems quite high. How many bags of urea (50kg) per hectare?',
        text_hi: 'नाइट्रोजन की दर काफी अधिक लगती है। प्रति हेक्टेयर यूरिया के कितने बोरे?',
        answerType: 'number',
        options: null,
        confidenceBoost: 0.35
      },
      'YIELD_UNIT_CHECK': {
        text: 'The yield seems low. Are you reporting in tonnes/ha or quintals/ha?',
        text_hi: 'उपज कम लगती है। क्या आप टन/हेक्टेयर या क्विंटल/हेक्टेयर में रिपोर्ट कर रहे हैं?',
        answerType: 'single_select',
        options: ['Tonnes per hectare (t/ha)', 'Quintals per hectare (q/ha)', 'Kilograms per hectare (kg/ha)'],
        confidenceBoost: 0.4
      }
    };

    function detectProbeNeeds() {
      var probeNeeds = [];
      var signals = CPOSL.qState.signals;
      var answered = CPOSL.qState.answered;
      
      if (CPOSL.qState.probeCount >= 4) return [];
      
      // Check for residue conflict
      if (answered['QC019'] && answered['QC017']) {
        var removal = String(answered['QC019'].Answer_Raw || '');
        var retention = String(answered['QC017'].Answer_Raw || '');
        if ((removal.indexOf('YES') >= 0 || removal.indexOf('ALL') >= 0) && parseInt(retention) > 30) {
          probeNeeds.push({ signal: 'RESIDUE_USE_CONFLICT', reason: 'Contradictory residue use', priority: 95 });
        }
      }
      
      // Check for zero-till conflict
      if (signals['TILLAGE_TYPE'] && signals['TILLAGE_TYPE'].value === 'ZERO_TILL' && answered['QM001']) {
        var passes = parseInt(answered['QM001'].Answer_Raw || 0);
        if (passes > 0) {
          probeNeeds.push({ signal: 'ZERO_TILL_CONFIRMATION', reason: 'Zero-till but passes > 0', priority: 90 });
        }
      }
      
      // Check for high nitrogen
      if (answered['QM019']) {
        var nRate = parseFloat(answered['QM019'].Answer_Raw || 0);
        if (nRate > 200) {
          probeNeeds.push({ signal: 'NITROGEN_RATE_VERIFY', reason: 'Unusually high N rate', priority: 85 });
        }
      }
      
      probeNeeds.sort(function(a, b) { return b.priority - a.priority; });
      return probeNeeds;
    }

    function getProbeQuestion(probeNeed) {
      var template = PROBE_TEMPLATES[probeNeed.signal];
      if (!template) return null;
      
      var lang = CPOSL.language;
      var questionText = (lang === 'HI' && template.text_hi) ? template.text_hi : template.text;
      
      return {
        probeId: probeNeed.signal,
        questionText: questionText,
        answerType: template.answerType,
        options: template.options,
        confidenceBoost: template.confidenceBoost,
        reason: probeNeed.reason
      };
    }

    function renderProbeQuestion() {
      var probe = CPOSL.qState.pendingProbe;
      if (!probe) return;
      
      var lang = CPOSL.language;
      var elQ = document.getElementById('qQuestionText');
      var elH = document.getElementById('qHelpText');
      var elA = document.getElementById('qAnswerBox');
      
      elQ.innerHTML = '<div class="probe-box">' +
        '<div style="display:flex;align-items:center;gap:12px">' +
        '<div style="font-size:28px">❓</div>' +
        '<div style="flex:1">' +
        '<div style="background:#2196F3;color:white;padding:4px 10px;border-radius:20px;font-size:11px;font-weight:600;display:inline-block;margin-bottom:6px">' +
        (lang === 'HI' ? 'त्वरित सत्यापन' : 'QUICK VERIFICATION') + '</div>' +
        '<div style="font-weight:600;color:#1976D2">' + escapeHtml(probe.questionText) + '</div>' +
        '</div></div></div>';
      
      elH.innerHTML = '<div style="font-size:12px;color:#1976D2;padding:8px;background:white;border-radius:6px;border-left:4px solid #2196F3">' +
        (lang === 'HI' ? 'कारण' : 'Reason') + ': ' + escapeHtml(probe.reason) + '</div>';
      
      elA.innerHTML = '';
      
      if (probe.answerType === 'single_select' && probe.options) {
        probe.options.forEach(function(opt, idx) {
          var div = document.createElement('div');
          div.style.cssText = 'display:flex;align-items:center;gap:10px;margin-bottom:8px';
          div.innerHTML = '<input type="radio" name="probeAnswer" value="' + escapeHtml(opt) + '" id="probe_' + idx + '">' +
            '<label for="probe_' + idx + '" style="cursor:pointer">' + escapeHtml(opt) + '</label>';
          elA.appendChild(div);
          div.querySelector('input').addEventListener('change', updateQuestionnaireUIState);
        });
      } else if (probe.answerType === 'number') {
        var inp = document.createElement('input');
        inp.type = 'number';
        inp.id = 'probeNumInput';
        inp.placeholder = lang === 'HI' ? 'संख्या दर्ज करें' : 'Enter number';
        inp.style.cssText = 'width:100%;padding:10px;border-radius:12px;border:2px solid #2196F3';
        elA.appendChild(inp);
        inp.addEventListener('input', updateQuestionnaireUIState);
      }
    }

    function processProbeAnswer(probeId, answer) {
      CPOSL.qState.answered['PROBE_' + probeId] = {
        Answer_Raw: answer,
        IsProbe: true
      };
      CPOSL.qState.probeCount++;
      
      var probe = CPOSL.qState.pendingProbe;
      var boost = probe ? probe.confidenceBoost : 0.3;
      var relatedSignal = probeId.split('_')[0];
      
      Object.keys(CPOSL.qState.signals).forEach(function(sigKey) {
        if (sigKey.indexOf(relatedSignal) >= 0) {
          var signal = CPOSL.qState.signals[sigKey];
          signal.confidence = Math.min(1.0, (signal.confidence || 0.5) + boost);
        }
      });
      
      CPOSL.qState.pendingProbe = null;
    }

    // ============================================================
    // CROP PARSER - Intelligent crop/season detection
    // ============================================================
    function parseCropAnswer(rawText) {
      if (!rawText || typeof rawText !== 'string') return null;
      
      var text = rawText.toLowerCase().trim();
      if (!text) return null;
      
      var cropMap = {
        'rice': 'RICE', 'paddy': 'RICE', 'dhan': 'RICE',
        'wheat': 'WHEAT', 'gehu': 'WHEAT', 'gehun': 'WHEAT',
        'maize': 'MAIZE', 'corn': 'MAIZE', 'makka': 'MAIZE',
        'sugarcane': 'SUGARCANE', 'ganna': 'SUGARCANE',
        'cotton': 'COTTON', 'kapas': 'COTTON',
        'soybean': 'SOYBEAN', 'soya': 'SOYBEAN',
        'chickpea': 'CHICKPEA', 'chana': 'CHICKPEA',
        'mustard': 'MUSTARD', 'sarso': 'MUSTARD',
        'potato': 'POTATO', 'aloo': 'POTATO',
        'vegetables': 'VEGETABLES', 'sabzi': 'VEGETABLES'
      };
      
      var seasonKeywords = {
        'kharif': 'KHARIF', 'rabi': 'RABI', 'summer': 'SUMMER', 'zaid': 'SUMMER',
        'monsoon': 'KHARIF', 'winter': 'RABI'
      };
      
      var result = { crops: [], cropSeasons: {}, signals: {} };
      var words = text.replace(/[,;]/g, ' ').split(/\s+/);
      
      words.forEach(function(word) {
        Object.keys(cropMap).forEach(function(pattern) {
          if (word === pattern || word === pattern + 's') {
            var cropCode = cropMap[pattern];
            if (result.crops.indexOf(cropCode) < 0) {
              result.crops.push(cropCode);
            }
          }
        });
        
        Object.keys(seasonKeywords).forEach(function(kw) {
          if (word === kw) {
            // Associate with last detected crop
            var lastCrop = result.crops[result.crops.length - 1];
            if (lastCrop) {
              if (!result.cropSeasons[lastCrop]) result.cropSeasons[lastCrop] = [];
              var season = seasonKeywords[kw];
              if (result.cropSeasons[lastCrop].indexOf(season) < 0) {
                result.cropSeasons[lastCrop].push(season);
              }
            }
          }
        });
      });
      
      // Generate signals
      if (result.crops.indexOf('RICE') >= 0) {
        result.signals['CROP_RICE_DETECTED'] = { value: 'YES', confidence: 0.9 };
      }
      if (result.crops.indexOf('WHEAT') >= 0) {
        result.signals['CROP_WHEAT_DETECTED'] = { value: 'YES', confidence: 0.9 };
      }
      
      if (result.crops.length >= 3) {
        result.signals['CROP_DIVERSITY'] = { value: 'HIGH', confidence: 0.8 };
      } else if (result.crops.length === 2) {
        result.signals['CROP_DIVERSITY'] = { value: 'MEDIUM', confidence: 0.8 };
      } else if (result.crops.length === 1) {
        result.signals['CROP_DIVERSITY'] = { value: 'LOW', confidence: 0.8 };
      }
      
      return result;
    }

    // ============================================================
    // ESTIMATION RULES - Convert qualitative to quantitative
    // ============================================================
    var ESTIMATION_RULES = {
      'TEXTUREPROXY_CLAYEY': {
        factors: [
          { varName: 'clayfraction', estimate: 30, confidence: 0.6 },
          { varName: 'sandfraction', estimate: 25, confidence: 0.5 }
        ]
      },
      'TEXTUREPROXY_SANDY': {
        factors: [
          { varName: 'sandfraction', estimate: 70, confidence: 0.65 },
          { varName: 'clayfraction', estimate: 10, confidence: 0.55 }
        ]
      },
      'DISTURBANCE_HIGH': {
        factors: [{ varName: 'tillageintensity', estimate: 5, confidence: 0.7 }]
      },
      'DISTURBANCE_LOW': {
        factors: [{ varName: 'tillageintensity', estimate: 0, confidence: 0.8 }]
      },
      'RESIDUERETENTION_HIGH': {
        factors: [{ varName: 'residuequantity', estimate: 4.5, confidence: 0.7 }]
      },
      'RESIDUERETENTION_LOW': {
        factors: [{ varName: 'residuequantity', estimate: 1.0, confidence: 0.6 }]
      }
    };

    function applyEstimationMappings() {
      var estimated = [];
      var signals = CPOSL.qState.signals;
      
      Object.keys(signals).forEach(function(signalKey) {
        var sigValue = signals[signalKey].value;
        var ruleKey = signalKey + '_' + sigValue;
        var rule = ESTIMATION_RULES[ruleKey];
        
        if (!rule) return;
        
        rule.factors.forEach(function(est) {
          var varKey = normKey(est.varName);
          var varData = CPOSL.idx.boundsByVar.get(varKey);
          if (!varData || varData.length === 0) return;
          
          // Only estimate if not already set
          if (!CPOSL.selections[est.varName]) {
            // Find matching class for estimated value
            var matchedClass = null;
            varData.forEach(function(row) {
              var lower = toNum(getField(row, ['Lower_Bound', 'LowerBound']));
              var upper = toNum(getField(row, ['Upper_Bound', 'UpperBound']));
              if ((lower === null || est.estimate >= lower) && (upper === null || est.estimate <= upper)) {
                matchedClass = getField(row, ['Class_Label', 'ClassLabel']);
              }
            });
            
            if (matchedClass) {
              CPOSL.selections[est.varName] = matchedClass;
              estimated.push({
                variable: est.varName,
                estimatedValue: est.estimate,
                classLabel: matchedClass,
                confidence: est.confidence,
                fromSignal: signalKey
              });
            }
          }
        });
      });
      
      return estimated;
    }

    // ============================================================
    // SIGNAL TO LITE FACTOR MAPPING
    // ============================================================
    function applySignalMappings() {
      var mappings = CPOSL.q.signalToLiteMap || [];
      var mapped = [];
      
      mappings.forEach(function(m) {
        if (!toBool(getField(m, ['Is_Active', 'IsActive'], true))) return;
        
        var sigKey = getField(m, ['Signal_Key', 'SignalKey']);
        var varName = getField(m, ['Lite_Variable_Name', 'Variable_Name']);
        var method = getField(m, ['Mapping_Method', 'MappingMethod'], 'DIRECT').toUpperCase();
        var whenValue = getField(m, ['When_Signal_Value', 'WhenValue']);
        var thenClass = getField(m, ['Then_Lite_Class', 'ThenClass']);
        var conf = toNum(getField(m, ['Confidence_0_1', 'Confidence'])) || 0.8;
        
        if (!sigKey || !varName) return;
        
        var signal = CPOSL.qState.signals[sigKey];
        if (!signal) return;
        
        // Check if signal value matches condition
        if (whenValue && signal.value !== whenValue) return;
        
        if (method === 'DIRECT' && thenClass) {
          // Don't override existing selections
          if (!CPOSL.selections[varName]) {
            CPOSL.selections[varName] = thenClass;
            mapped.push({
              signal: sigKey,
              variable: varName,
              classLabel: thenClass,
              confidence: conf
            });
          }
        }
      });
      
      return mapped;
    }

    // ============================================================
    // BACKEND API CALLS
    // ============================================================
    function gsRun(fnName) {
      var args = Array.prototype.slice.call(arguments, 1);
      return new Promise(function(resolve, reject) {
        if (typeof google === 'undefined' || !google.script || !google.script.run) {
          reject(new Error('Apps Script runtime not available'));
          return;
        }
        var runner = google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject);
        if (typeof runner[fnName] !== 'function') {
          reject(new Error('Function not found: ' + fnName));
          return;
        }
        runner[fnName].apply(runner, args);
      });
    }

    function getCPOSLiteTables() {
      return gsRun('getCPOSLiteTables');
    }

    function getCPOSQuestionnaireConfig() {
      return gsRun('getCPOSQuestionnaireConfig');
    }

    // ============================================================
    // INDEX BUILDERS
    // ============================================================
    function buildLiteIndexes() {
      var bounds = CPOSL.data.bounds || [];
      var desir = CPOSL.data.desirability || [];
      var wts = CPOSL.data.weights || [];

      var boundsByVar = new Map();
      bounds.forEach(function(r) {
        var varName = getField(r, ['Variable_Name', 'VariableName', 'variable_name']);
        if (!varName) return;
        var key = normKey(varName);
        if (!boundsByVar.has(key)) boundsByVar.set(key, []);
        boundsByVar.get(key).push(r);
      });
      
      boundsByVar.forEach(function(list) {
        list.sort(function(a, b) {
          return (toNum(a.Class_Order) || 0) - (toNum(b.Class_Order) || 0);
        });
      });

      var desirIdx = new Map();
      desir.forEach(function(r) {
        var varName = getField(r, ['Variable_Name', 'VariableName']);
        var cls = getField(r, ['Class_Label', 'ClassLabel']);
        var pw = getField(r, ['Pathway', 'pathway']);
        var d = toNum(getField(r, ['Desirability_0_1', 'Desirability']));
        if (!varName || !cls || !pw || d === null) return;
        desirIdx.set(normKey(varName) + '|' + normKey(cls) + '|' + normKey(pw), Math.max(0, Math.min(1, d)));
      });

      var wIdx = new Map();
      wts.forEach(function(r) {
        var varName = getField(r, ['Variable_Name', 'VariableName']);
        var pw = getField(r, ['Pathway', 'pathway']);
        var w = toNum(getField(r, ['Sensitivity_Weight_0_10', 'weight']));
        if (!varName || !pw || w === null) return;
        wIdx.set(normKey(varName) + '|' + normKey(pw), Math.max(0, Math.min(10, w)));
      });

      CPOSL.idx.boundsByVar = boundsByVar;
      CPOSL.idx.desirIdx = desirIdx;
      CPOSL.idx.wIdx = wIdx;

      console.log('[CPOS] Lite indexes built:', {
        boundsVars: boundsByVar.size,
        desirKeys: desirIdx.size,
        weightKeys: wIdx.size
      });
    }

    function buildQuestionnaireIndexes() {
      var idx = CPOSL.q.idx;
      idx.qBankById = new Map();
      idx.qOptionsByQ = new Map();
      idx.qDerivByWhenQ = new Map();
      idx.qRoutesByCurrentQ = new Map();
      idx.qSignalMapByKey = new Map();
      idx.startQuestions = [];

      var bank = CPOSL.q.bank || [];
      var options = CPOSL.q.options || [];
      var deriv = CPOSL.q.derivationRules || [];
      var routes = CPOSL.q.routingRules || [];
      var signalMap = CPOSL.q.signalToLiteMap || [];

      bank.forEach(function(r) {
        var qid = getField(r, ['Question_ID', 'QuestionID', 'question_id']);
        if (!qid) return;
        var active = toBool(getField(r, ['Is_Active', 'IsActive', 'is_active'], true));
        if (!active) return;

        r.Question_ID = qid;
        r.Is_Active = active;
        r.Sequence = toNum(getField(r, ['Sequence', 'sequence'])) || 999;
        r.Is_Required = toBool(getField(r, ['Is_Required', 'IsRequired'], false));

        idx.qBankById.set(qid, r);
      });

      var sorted = Array.from(idx.qBankById.values()).sort(function(a, b) {
        return a.Sequence - b.Sequence;
      });
      if (sorted.length > 0) {
        idx.startQuestions = [sorted[0].Question_ID];
      }

      options.forEach(function(o) {
        var qid = getField(o, ['Question_ID', 'QuestionID']);
        if (!qid) return;
        if (!idx.qOptionsByQ.has(qid)) idx.qOptionsByQ.set(qid, []);
        idx.qOptionsByQ.get(qid).push(o);
      });

      deriv.forEach(function(d) {
        var whenQ = getField(d, ['When_Question_ID', 'WhenQuestionID']);
        if (!whenQ) return;
        if (!idx.qDerivByWhenQ.has(whenQ)) idx.qDerivByWhenQ.set(whenQ, []);
        idx.qDerivByWhenQ.get(whenQ).push(d);
      });

      routes.forEach(function(r) {
        var fromQ = getField(r, ['From_Question_ID', 'FromQuestionID', 'Current_Question_ID']);
        if (!fromQ) return;
        if (!idx.qRoutesByCurrentQ.has(fromQ)) idx.qRoutesByCurrentQ.set(fromQ, []);
        idx.qRoutesByCurrentQ.get(fromQ).push(r);
      });

      signalMap.forEach(function(sm) {
        var sig = getField(sm, ['Signal_Key', 'SignalKey']);
        if (!sig) return;
        if (!idx.qSignalMapByKey.has(sig)) idx.qSignalMapByKey.set(sig, []);
        idx.qSignalMapByKey.get(sig).push(sm);
      });

      CPOSL.q.available = idx.qBankById.size > 0 && idx.startQuestions.length > 0;

      console.log('[CPOS][Q] Questionnaire indexes built:', {
        bank: idx.qBankById.size,
        options: idx.qOptionsByQ.size,
        deriv: idx.qDerivByWhenQ.size,
        routes: idx.qRoutesByCurrentQ.size,
        signalMap: idx.qSignalMapByKey.size,
        starts: idx.startQuestions,
        available: CPOSL.q.available
      });
    }

    // ============================================================
    // UI BUILDERS
    // ============================================================
    function buildFactorForm() {
      var container = document.getElementById('factorForm');
      if (!container) return;
      container.innerHTML = '';

      var boundsByVar = CPOSL.idx.boundsByVar;
      if (!boundsByVar || boundsByVar.size === 0) {
        container.innerHTML = '<div class="small" style="color:#991b1b">No factors loaded.</div>';
        return;
      }

      boundsByVar.forEach(function(rows, varKey) {
        var firstRow = rows[0] || {};
        var varName = getField(firstRow, ['Variable_Name', 'VariableName']) || varKey;
        var displayName = getField(firstRow, ['Factor_Display_Name', 'FactorDisplayName']) || varName;
        var unit = getField(firstRow, ['Unit', 'unit']) || '';
        var cat = getField(firstRow, ['Factor_Category', 'FactorCategory']) || '';

        var field = document.createElement('div');
        field.className = 'field';
        
        var optionsHtml = '<option value="">— Select —</option>';
        rows.forEach(function(r) {
          var cls = getField(r, ['Class_Label', 'ClassLabel']);
          optionsHtml += '<option value="' + escapeHtml(cls) + '">' + escapeHtml(cls) + '</option>';
        });
        
        field.innerHTML = 
          '<label><span>' + escapeHtml(displayName) + '</span><span class="cat">' + escapeHtml(unit || cat) + '</span></label>' +
          '<select id="sel_' + escapeHtml(varKey) + '" data-var="' + escapeHtml(varName) + '">' + optionsHtml + '</select>';
        container.appendChild(field);

        var sel = field.querySelector('select');
        if (sel) {
          // Restore selection if exists
          if (CPOSL.selections[varName]) {
            sel.value = CPOSL.selections[varName];
          }
          sel.addEventListener('change', function() {
            onSelectionChange(varName, sel.value);
          });
        }
      });
      
      updateEvalGate();
    }

    function onSelectionChange(varName, classLabel) {
      if (classLabel) {
        CPOSL.selections[varName] = classLabel;
      } else {
        delete CPOSL.selections[varName];
      }
      updateEvalGate();
      updateExplainBox();
    }

    function updateEvalGate() {
      var btn = document.getElementById('btnEvaluate');
      var hint = document.getElementById('evalGateHint');
      var count = Object.keys(CPOSL.selections).length;

      if (btn) btn.disabled = count === 0;
      if (hint) hint.textContent = count > 0 ? count + ' factor(s) selected' : '';
    }

    function updateExplainBox() {
      var box = document.getElementById('notesBox');
      if (!box) return;

      var sels = CPOSL.selections;
      var keys = Object.keys(sels);
      if (keys.length === 0) {
        box.textContent = 'Enter values to view class, desirability, and pathway context here.';
        return;
      }

      var text = '';
      keys.forEach(function(varName) {
        text += varName + ': ' + sels[varName] + '\n';
      });
      box.textContent = text;
    }

    function clearSelections() {
      CPOSL.selections = {};
      document.querySelectorAll('#factorForm select').forEach(function(sel) {
        sel.value = '';
      });
      updateEvalGate();
      updateExplainBox();
    }

    // ============================================================
    // QUESTIONNAIRE UI
    // ============================================================
    function updateQuestionnaireUIState() {
      var state = CPOSL.qState;
      var idx = CPOSL.q.idx;

      var hasBank = idx.qBankById && idx.qBankById.size > 0;
      var hasStart = idx.startQuestions && idx.startQuestions.length > 0;
      var qReady = hasBank && hasStart;
      var inProgress = !!state.current;
      var isProbe = state.current && String(state.current).indexOf('PROBE_') === 0;

      var elProg = document.getElementById('qProgress');
      if (elProg) {
        var answered = Object.keys(state.answered).length;
        var target = state.minTarget || 5;
        var pct = target > 0 ? Math.round((answered / target) * 100) : 0;
        elProg.textContent = 'Answered ' + answered + ' / target ' + target + ' (' + pct + '%)';
      }

      var btnStart = document.getElementById('btnQStart');
      var btnBack = document.getElementById('btnQBack');
      var btnSkip = document.getElementById('btnQSkip');
      var btnNext = document.getElementById('btnQNext');
      var btnFinish = document.getElementById('btnQFinish');

      if (btnStart) btnStart.disabled = !qReady || inProgress;
      if (btnBack) btnBack.disabled = !inProgress || state.history.length === 0;
      if (btnSkip) btnSkip.disabled = !inProgress || isProbe;

      var hasAnswer = inProgress && validateAnswer(readAnswerFromUI());
      if (btnNext) btnNext.disabled = !hasAnswer;

      var answeredCount = Object.keys(state.answered).length;
      if (btnFinish) btnFinish.disabled = !inProgress || answeredCount < 1;

      var elQ = document.getElementById('qQuestionText');
      if (!qReady && elQ && !inProgress) {
        elQ.innerHTML = '<span style="color:#991b1b;font-weight:600">Questionnaire not available.</span><br>' +
          '<small style="color:#666">Bank: ' + (idx.qBankById ? idx.qBankById.size : 0) + 
          ', Starts: ' + (idx.startQuestions ? idx.startQuestions.length : 0) + '</small>';
      }
    }

    function renderQuestionUI() {
      var qid = CPOSL.qState.current;
      var elQ = document.getElementById('qQuestionText');
      var elH = document.getElementById('qHelpText');
      var elA = document.getElementById('qAnswerBox');

      if (!elQ || !elH || !elA) return;

      // Handle probe questions
      if (qid && String(qid).indexOf('PROBE_') === 0) {
        renderProbeQuestion();
        return;
      }

      if (!qid) {
        elQ.textContent = 'No current question.';
        elH.textContent = '';
        elA.innerHTML = '';
        return;
      }

      var qRow = CPOSL.q.idx.qBankById.get(qid);
      if (!qRow) {
        elQ.textContent = 'Question ' + qid + ' not found.';
        elH.textContent = '';
        elA.innerHTML = '';
        return;
      }

      var lang = CPOSL.language;
      var questionText = (lang === 'HI' && qRow.Question_Text_HI)
        ? qRow.Question_Text_HI
        : (getField(qRow, ['Question_Text_EN', 'Question_Text', 'QuestionText']) || qid);
      var helpText = (lang === 'HI' && qRow.Help_Text_HI)
        ? qRow.Help_Text_HI
        : (getField(qRow, ['Help_Text_EN', 'Help_Text', 'HelpText']) || '');

      elQ.textContent = questionText;
      elH.textContent = helpText;
      elA.innerHTML = '';

      var prevAnswer = CPOSL.qState.answered[qid];
      var prevRaw = prevAnswer ? prevAnswer.Answer_Raw : '';

      var qType = String(getField(qRow, ['Answer_Type', 'AnswerType']) || '').toLowerCase();
      var opts = CPOSL.q.idx.qOptionsByQ.get(qid) || [];

      if (qType === 'single_select' && opts.length > 0) {
        opts.forEach(function(opt) {
          var code = getField(opt, ['Option_Code', 'OptionCode']) || '';
          var label = (lang === 'HI' && opt.Option_Label_HI)
            ? opt.Option_Label_HI
            : (getField(opt, ['Option_Label_EN', 'Option_Label', 'OptionLabel']) || code);
          var checked = prevRaw === code ? 'checked' : '';

          var div = document.createElement('div');
          div.style.cssText = 'display:flex;align-items:center;gap:10px;margin-bottom:8px';
          div.innerHTML = '<input type="radio" name="q_' + escapeHtml(qid) + '" value="' + escapeHtml(code) + '" ' +
            'id="q_' + qid + '_' + code + '" ' + checked + '>' +
            '<label for="q_' + qid + '_' + code + '" style="cursor:pointer">' + escapeHtml(label) + '</label>';
          elA.appendChild(div);
          div.querySelector('input').addEventListener('change', updateQuestionnaireUIState);
        });
      } else if (qType === 'multi_select' && opts.length > 0) {
        var prevCodes = String(prevRaw || '').split(',').map(function(x) { return x.trim(); });
        opts.forEach(function(opt) {
          var code = getField(opt, ['Option_Code', 'OptionCode']) || '';
          var label = (lang === 'HI' && opt.Option_Label_HI)
            ? opt.Option_Label_HI
            : (getField(opt, ['Option_Label_EN', 'Option_Label', 'OptionLabel']) || code);
          var checked = prevCodes.indexOf(code) >= 0 ? 'checked' : '';

          var div = document.createElement('div');
          div.style.cssText = 'display:flex;align-items:center;gap:10px;margin-bottom:8px';
          div.innerHTML = '<input type="checkbox" name="q_' + escapeHtml(qid) + '" value="' + escapeHtml(code) + '" ' +
            'id="q_' + qid + '_' + code + '" ' + checked + '>' +
            '<label for="q_' + qid + '_' + code + '" style="cursor:pointer">' + escapeHtml(label) + '</label>';
          elA.appendChild(div);
          div.querySelector('input').addEventListener('change', updateQuestionnaireUIState);
        });
      } else if (qType === 'number') {
        var inp = document.createElement('input');
        inp.type = 'number';
        inp.id = 'q_' + qid + '_num';
        inp.placeholder = lang === 'HI' ? 'संख्या दर्ज करें' : 'Enter numeric value';
        inp.value = prevRaw || '';
        inp.style.cssText = 'width:100%;padding:10px;border-radius:12px;border:1px solid var(--stroke2)';
        elA.appendChild(inp);
        inp.addEventListener('input', updateQuestionnaireUIState);
      } else {
        var inp = document.createElement('input');
        inp.type = 'text';
        inp.id = 'q_' + qid + '_text';
        inp.placeholder = lang === 'HI' ? 'अपना उत्तर दर्ज करें' : 'Enter your answer';
        inp.value = prevRaw || '';
        inp.style.cssText = 'width:100%;padding:10px;border-radius:12px;border:1px solid var(--stroke2)';
        elA.appendChild(inp);
        inp.addEventListener('input', updateQuestionnaireUIState);
      }
    }

    function readAnswerFromUI() {
      var qid = CPOSL.qState.current;
      if (!qid) return null;

      // Handle probe questions
      if (String(qid).indexOf('PROBE_') === 0) {
        var radio = document.querySelector('input[name="probeAnswer"]:checked');
        if (radio) return radio.value;
        var numInput = document.getElementById('probeNumInput');
        if (numInput && numInput.value.trim()) return numInput.value.trim();
        return null;
      }

      var qRow = CPOSL.q.idx.qBankById.get(qid);
      if (!qRow) return null;

      var qType = String(getField(qRow, ['Answer_Type', 'AnswerType']) || '').toLowerCase();

      if (qType === 'single_select') {
        var radio = document.querySelector('input[name="q_' + qid + '"]:checked');
        return radio ? radio.value : null;
      } else if (qType === 'multi_select') {
        var boxes = document.querySelectorAll('input[name="q_' + qid + '"]:checked');
        var codes = [];
        boxes.forEach(function(b) { codes.push(b.value); });
        return codes.length ? codes.join(',') : null;
      } else if (qType === 'number') {
        var inp = document.getElementById('q_' + qid + '_num');
        return inp ? inp.value.trim() : null;
      } else {
        var inp = document.getElementById('q_' + qid + '_text');
        return inp ? inp.value.trim() : null;
      }
    }

    function validateAnswer(answerRaw) {
      return answerRaw !== null && answerRaw !== undefined && String(answerRaw).trim() !== '';
    }

    function updateDerivedBox() {
      var box = document.getElementById('qDerivedBox');
      if (!box) return;

      var signals = CPOSL.qState.signals;
      var keys = Object.keys(signals);

      if (keys.length === 0) {
        box.textContent = 'Signals and auto-filled factors will appear here.';
        return;
      }

      var html = '<b>Derived Signals (' + keys.length + '):</b>\n';
      keys.forEach(function(k) {
        var sig = signals[k];
        var conf = sig.confidence ? (sig.confidence * 100).toFixed(0) + '%' : '—';
        html += '• ' + escapeHtml(k) + ': ' + escapeHtml(sig.value) + ' (conf: ' + conf + ')\n';
      });
      
      // Show mapped factors
      var mapped = Object.keys(CPOSL.selections);
      if (mapped.length > 0) {
        html += '\n<b>Auto-filled Factors (' + mapped.length + '):</b>\n';
        mapped.forEach(function(k) {
          html += '• ' + escapeHtml(k) + ' → ' + escapeHtml(CPOSL.selections[k]) + '\n';
        });
      }
      
      box.innerHTML = html;
    }

    // ============================================================
    // QUESTIONNAIRE ACTIONS
    // ============================================================
    function qStart() {
      var starts = CPOSL.q.idx.startQuestions;
      if (!starts || starts.length === 0) {
        alert('No start questions available.');
        return;
      }

      CPOSL.qState.sessionId = 'Q-' + Date.now();
      CPOSL.qState.answered = {};
      CPOSL.qState.signals = {};
      CPOSL.qState.history = [];
      CPOSL.qState.current = starts[0];
      CPOSL.qState.stop = false;
      CPOSL.qState.probeCount = 0;
      CPOSL.qState.pendingProbe = null;
      CPOSL.qState.pendingWarning = null;
      CPOSL.selections = {}; // Reset selections

      renderQuestionUI();
      updateQuestionnaireUIState();
      setStatus(true, 'Questionnaire started');
    }

    function qNext() {
      var qid = CPOSL.qState.current;
      if (!qid) return;

      var answer = readAnswerFromUI();
      if (!validateAnswer(answer)) {
        alert('Please provide an answer.');
        return;
      }

      // Handle probe answer
      if (String(qid).indexOf('PROBE_') === 0) {
        var probeId = qid.replace('PROBE_', '');
        processProbeAnswer(probeId, answer);
        proceedToNextQuestion();
        return;
      }

      // Parse special answers (e.g., crop lists)
      var parsedData = null;
      var normalizedAnswer = answer;
      if (qid === 'Q_A1' || qid === 'Q_A2') {
        parsedData = parseCropAnswer(answer);
        if (parsedData && parsedData.crops.length > 0) {
          normalizedAnswer = parsedData.crops.join(',');
          Object.keys(parsedData.signals).forEach(function(key) {
            var sig = parsedData.signals[key];
            CPOSL.qState.signals[key] = {
              value: sig.value,
              confidence: sig.confidence,
              sourceQ: qid
            };
          });
        }
      }

      // Save answer
      CPOSL.qState.answered[qid] = {
        Question_ID: qid,
        Answer_Raw: answer,
        Answer_Normalized: normalizedAnswer,
        Parsed_Data: parsedData,
        Answered_At: new Date().toISOString()
      };

      // Apply derivations
      applyDerivationsForQuestion(qid, normalizedAnswer);
      
      // Apply routing rules
      applyRoutingForQuestion(qid, normalizedAnswer);

      // Check consistency (only every 5 questions to avoid overload)
      var answeredCount = Object.keys(CPOSL.qState.answered).length;
      if (answeredCount % 5 === 0) {
        var violations = checkAnswerConsistency();
        if (violations.length > 0) {
          var highSeverity = violations.filter(function(v) { return v.severity === 'HIGH'; });
          if (highSeverity.length > 0) {
            showConsistencyWarning(highSeverity[0]);
            return;
          }
        }
      }

      // Check if probe is needed (every 5 questions after 15)
      if (answeredCount >= 15 && answeredCount % 5 === 0 && CPOSL.qState.probeCount < 4) {
        var probeNeeds = detectProbeNeeds();
        if (probeNeeds.length > 0) {
          var probe = getProbeQuestion(probeNeeds[0]);
          if (probe) {
            CPOSL.qState.pendingProbe = probe;
            CPOSL.qState.history.push(qid);
            CPOSL.qState.current = 'PROBE_' + probe.probeId;
            renderQuestionUI();
            updateQuestionnaireUIState();
            return;
          }
        }
      }

      proceedToNextQuestion();
    }

    function proceedToNextQuestion() {
      var qid = CPOSL.qState.current;
      
      // Remove PROBE_ prefix if present
      if (qid && String(qid).indexOf('PROBE_') === 0) {
        qid = null; // Don't add to history again
      } else if (qid) {
        CPOSL.qState.history.push(qid);
      }

      // Find next question
      var next = findNextQuestion(CPOSL.qState.history[CPOSL.qState.history.length - 1]);

      if (next) {
        CPOSL.qState.current = next;
        renderQuestionUI();
      } else {
        CPOSL.qState.current = null;
        document.getElementById('qQuestionText').textContent = 'Questionnaire complete! Click Finish to apply results.';
        document.getElementById('qHelpText').textContent = '';
        document.getElementById('qAnswerBox').innerHTML = '';
      }

      updateQuestionnaireUIState();
      updateDerivedBox();
    }

    function qBack() {
      var history = CPOSL.qState.history;
      if (history.length === 0) return;

      var prevQ = history.pop();
      CPOSL.qState.current = prevQ;
      CPOSL.qState.pendingProbe = null;
      CPOSL.qState.pendingWarning = null;
      document.getElementById('qNavStatus').textContent = '';
      renderQuestionUI();
      updateQuestionnaireUIState();
    }

    function qSkip() {
      var qid = CPOSL.qState.current;
      if (!qid) return;
      if (String(qid).indexOf('PROBE_') === 0) return; // Can't skip probes

      CPOSL.qState.answered[qid] = {
        Question_ID: qid,
        Answer_Raw: '',
        Answer_Normalized: 'SKIPPED',
        Answered_At: new Date().toISOString()
      };

      proceedToNextQuestion();
    }

    function qFinish() {
      console.log('[Q] Finishing questionnaire...');
      
      // Rebuild signals
      rebuildSignalsFromAllAnswers();
      
      // Apply signal-to-factor mappings
      var mapped = applySignalMappings();
      console.log('[Q] Signal mappings applied:', mapped.length);
      
      // Apply estimation rules
      var estimated = applyEstimationMappings();
      console.log('[Q] Estimations applied:', estimated.length);
      
      // Update UI
      CPOSL.qState.current = null;
      var answeredCount = Object.keys(CPOSL.qState.answered).filter(function(k) {
        return CPOSL.qState.answered[k].Answer_Normalized !== 'SKIPPED';
      }).length;
      var signalCount = Object.keys(CPOSL.qState.signals).length;
      var factorCount = Object.keys(CPOSL.selections).length;
      
      document.getElementById('qQuestionText').textContent = 
        'Questionnaire complete! Answered ' + answeredCount + ' questions, derived ' + 
        signalCount + ' signals, auto-filled ' + factorCount + ' factors.';
      document.getElementById('qHelpText').textContent = '';
      document.getElementById('qAnswerBox').innerHTML = 
        '<div class="mutedBox">Click Step 1 to review auto-filled factors, or Step 2 for pathway analysis.</div>';
      
      updateQuestionnaireUIState();
      updateDerivedBox();
      
      // Rebuild factor form with auto-filled values
      buildFactorForm();
      
      setStatus(true, 'Questionnaire complete: ' + answeredCount + ' answers, ' + factorCount + ' factors');
      
      console.log('[Q] Final signals:', CPOSL.qState.signals);
      console.log('[Q] Final selections:', CPOSL.selections);
    }

    function findNextQuestion(currentQid) {
      // First check queue from routing
      if (CPOSL.qState.queue && CPOSL.qState.queue.length > 0) {
        return CPOSL.qState.queue.shift();
      }
      
      var allQuestions = Array.from(CPOSL.q.idx.qBankById.values())
        .filter(function(q) { return q.Is_Active !== false; })
        .sort(function(a, b) { return (a.Sequence || 999) - (b.Sequence || 999); });

      var currentIdx = -1;
      if (currentQid) {
        currentIdx = allQuestions.findIndex(function(q) { return q.Question_ID === currentQid; });
      }

      for (var i = currentIdx + 1; i < allQuestions.length; i++) {
        var q = allQuestions[i];
        if (!CPOSL.qState.answered[q.Question_ID]) {
          return q.Question_ID;
        }
      }
      return null;
    }

    function applyDerivationsForQuestion(qid, answerRaw) {
      var rules = CPOSL.q.idx.qDerivByWhenQ.get(qid) || [];

      rules.forEach(function(rule) {
        var active = toBool(getField(rule, ['Is_Active', 'IsActive'], true));
        if (!active) return;

        var op = String(getField(rule, ['When_Operator', 'WhenOperator'], '')).toUpperCase();
        var whenVal = String(getField(rule, ['When_Value', 'WhenValue'], ''));
        var signalKey = String(getField(rule, ['Then_Signal_Key', 'ThenSignalKey'], ''));
        var signalVal = String(getField(rule, ['Then_Signal_Value', 'ThenSignalValue'], ''));
        var conf = toNum(getField(rule, ['Then_Signal_Score', 'ThenSignalScore'])) || 1.0;

        if (!signalKey) return;

        var matches = false;
        var ans = String(answerRaw).trim();

        if (op === 'EQUALS' || op === '=') matches = ans === whenVal;
        else if (op === '!=' || op === 'NOT_EQUALS') matches = ans !== whenVal;
        else if (op === 'CONTAINS' || op === 'IN') matches = ans.toLowerCase().indexOf(whenVal.toLowerCase()) >= 0;
        else if (op === '>') matches = toNum(ans) > toNum(whenVal);
        else if (op === '>=') matches = toNum(ans) >= toNum(whenVal);
        else if (op === '<') matches = toNum(ans) < toNum(whenVal);
        else if (op === '<=') matches = toNum(ans) <= toNum(whenVal);

        if (matches) {
          var existing = CPOSL.qState.signals[signalKey];
          if (!existing || conf > (existing.confidence || 0)) {
            CPOSL.qState.signals[signalKey] = {
              value: signalVal,
              confidence: conf,
              sourceQ: qid
            };
          }
        }
      });
    }

    function applyRoutingForQuestion(qid, answerRaw) {
      var rules = CPOSL.q.idx.qRoutesByCurrentQ.get(qid) || [];
      
      rules.forEach(function(rule) {
        var active = toBool(getField(rule, ['Is_Active', 'IsActive'], true));
        if (!active) return;
        
        var sigKey = getField(rule, ['Condition_Signal_Key', 'ConditionSignalKey']);
        var op = String(getField(rule, ['Condition_Operator', 'ConditionOperator'], '')).toUpperCase();
        var condVal = getField(rule, ['Condition_Value', 'ConditionValue']);
        var nextQ = getField(rule, ['Next_Question_ID', 'NextQuestionID']);
        var action = String(getField(rule, ['Route_Action', 'RouteAction'], 'ASK')).toUpperCase();
        
        var matches = false;
        
        if (sigKey && sigKey !== 'ANY') {
          var signal = CPOSL.qState.signals[sigKey];
          if (!signal) return;
          var sigVal = String(signal.value || '');
          
          if (op === 'EQUALS' || op === '=') matches = sigVal === condVal;
          else if (op === '!=') matches = sigVal !== condVal;
          else if (op === 'CONTAINS') matches = sigVal.toLowerCase().indexOf(condVal.toLowerCase()) >= 0;
        } else {
          matches = true;
        }
        
        if (!matches) return;
        
        if (action === 'ASK' && nextQ) {
          if (!CPOSL.qState.answered[nextQ] && (!CPOSL.qState.queue || CPOSL.qState.queue.indexOf(nextQ) < 0)) {
            if (!CPOSL.qState.queue) CPOSL.qState.queue = [];
            CPOSL.qState.queue.push(nextQ);
          }
        } else if (action === 'SKIP_TO' && nextQ) {
          CPOSL.qState.queue = [nextQ];
        } else if (action === 'END') {
          CPOSL.qState.stop = true;
        }
      });
    }

    function rebuildSignalsFromAllAnswers() {
      CPOSL.qState.signals = {};
      Object.keys(CPOSL.qState.answered).forEach(function(qid) {
        var ans = CPOSL.qState.answered[qid];
        if (ans && ans.Answer_Normalized !== 'SKIPPED') {
          applyDerivationsForQuestion(qid, ans.Answer_Raw || ans.Answer_Normalized);
        }
      });
    }

    // ============================================================
    // EVALUATION & RESULTS
    // ============================================================
    function evaluateAndGo() {
      var sels = CPOSL.selections;
      if (Object.keys(sels).length === 0) {
        alert('Please select at least one factor.');
        return;
      }

      setStatus(false, 'Evaluating...');

      gsRun('evaluateCPOS_Lite_v1', sels, { signals: CPOSL.qState.signals })
        .then(function(result) {
          console.log('[CPOS] Evaluation result:', result);
          CPOSL.lastResults = result;
          renderResults(result);
          goStep(2);
          setStatus(true, 'Evaluation complete');
        })
        .catch(function(err) {
          console.error('[CPOS] Evaluation failed:', err);
          setStatus(false, 'Evaluation failed: ' + (err && err.message ? err.message : err));
        });
    }

    function renderResults(result) {
      var grid = document.getElementById('screeningGrid');
      var recap = document.getElementById('selectionRecap');

      if (!grid) return;
      grid.innerHTML = '';

      var pathClasses = {
        'RP-SOC': 'path-rp',
        'AWD-CH₄': 'path-awd',
        'BIOCHAR': 'path-bio',
        'ERW': 'path-erw'
      };

      var results = (result && result.results) ? result.results : {};

      CPOSL.PATHWAYS.forEach(function(pw) {
        var r = results[pw] || {};
        var card = document.createElement('div');
        card.className = 'pathCard ' + (pathClasses[pw] || '');

        var eligClass = r.eligibility === 'YES' ? 'ok' : (r.eligibility === 'NO' ? 'bad' : 'warn');
        var prioClass = r.priority === 'HIGH' ? 'ok' : (r.priority === 'LOW' ? 'warn' : '');

        var reasonsHtml = '';
        if (r.reasons && r.reasons.length) {
          reasonsHtml = '<ul class="list">';
          r.reasons.forEach(function(x) { reasonsHtml += '<li>' + escapeHtml(x) + '</li>'; });
          reasonsHtml += '</ul>';
        }

        card.innerHTML =
          '<div class="pathTop">' +
            '<h4 class="pathName">' + escapeHtml(pw) + '</h4>' +
            '<div class="pathMeta">' +
              '<span class="pill ' + eligClass + '">' + escapeHtml(r.eligibility || 'N/A') + '</span>' +
              '<span class="pill ' + prioClass + '">' + escapeHtml(r.priority || 'N/A') + '</span>' +
            '</div>' +
          '</div>' +
          '<div class="small">' + escapeHtml(r.final_text || '') + '</div>' +
          reasonsHtml;
        grid.appendChild(card);
      });

      if (recap) {
        recap.innerHTML = '';
        Object.keys(CPOSL.selections).forEach(function(k) {
          var v = CPOSL.selections[k];
          var chip = document.createElement('div');
          chip.className = 'chip';
          chip.innerHTML = '<span class="k">' + escapeHtml(k) + '</span> <span>' + escapeHtml(v) + '</span>';
          recap.appendChild(chip);
        });
      }

      updateSummaryPanel(results);
    }

    function updateSummaryPanel(results) {
      var recStack = document.getElementById('recStack');
      var condStack = document.getElementById('condStack');
      var exclStack = document.getElementById('exclStack');
      var headline = document.getElementById('headlineBox');

      if (recStack) recStack.innerHTML = '';
      if (condStack) condStack.innerHTML = '';
      if (exclStack) exclStack.innerHTML = '';

      var rec = [], cond = [], excl = [];

      CPOSL.PATHWAYS.forEach(function(pw) {
        var r = results[pw] || {};
        if (r.eligibility === 'YES' && r.priority === 'HIGH') rec.push(pw);
        else if (r.eligibility === 'YES' || r.eligibility === 'CONDITIONAL') cond.push(pw);
        else excl.push(pw);
      });

      rec.forEach(function(pw) {
        if (recStack) recStack.innerHTML += '<span class="pill ok">' + escapeHtml(pw) + '</span> ';
      });
      cond.forEach(function(pw) {
        if (condStack) condStack.innerHTML += '<span class="pill warn">' + escapeHtml(pw) + '</span> ';
      });
      excl.forEach(function(pw) {
        if (exclStack) exclStack.innerHTML += '<span class="pill bad">' + escapeHtml(pw) + '</span> ';
      });

      if (headline) {
        headline.textContent = rec.length > 0
          ? 'Recommended: ' + rec.join(', ')
          : 'No pathways strongly recommended. Consider conditional options.';
      }
    }

    // ============================================================
    // SAVE ASSESSMENT
    // ============================================================
    function saveAssessment() {
      var status = document.getElementById('saveStatus');
      if (status) status.textContent = 'Saving...';

      var payload = {
        Client_ID: (document.getElementById('metaClientId') || {}).value || 'Default',
        Site_ID: (document.getElementById('metaSiteId') || {}).value || '',
        Site_Name: (document.getElementById('metaSiteName') || {}).value || '',
        Crop_System: (document.getElementById('metaCropSystem') || {}).value || '',
        selections: CPOSL.selections,
        signals: CPOSL.qState.signals,
        results: CPOSL.lastResults ? CPOSL.lastResults.results : {},
        Notes: (document.getElementById('metaNotes') || {}).value || ''
      };

      gsRun('saveCPOSLiteAssessment', payload)
        .then(function(res) {
          if (status) status.textContent = res && res.ok ? '✓ Saved: ' + res.Assessment_ID : '✗ Save failed';
        })
        .catch(function(err) {
          if (status) status.textContent = '✗ Error: ' + (err && err.message ? err.message : err);
        });
    }

    // ============================================================
    // LANGUAGE TOGGLE
    // ============================================================
    function wireLanguageToggle() {
      var en = document.getElementById('langEN');
      var hi = document.getElementById('langHI');
      if (!en || !hi) return;

      function apply() {
        CPOSL.language = hi.checked ? 'HI' : 'EN';
        if (CPOSL.qState.current) renderQuestionUI();
        updateQuestionnaireUIState();
      }

      en.addEventListener('change', apply);
      hi.addEventListener('change', apply);
    }

    // ============================================================
    // INITIALIZATION
    // ============================================================
    function init() {
      console.log('[CPOS-Lite] init() starting...');
      setStatus(false, 'Loading...');

      getCPOSLiteTables()
        .then(function(liteTables) {
          console.log('[CPOS] getCPOSLiteTables() result:', liteTables);

          if (!liteTables || (!liteTables.ok && !liteTables.bounds)) {
            setStatus(false, 'Failed to load Lite tables');
            return Promise.reject('No Lite tables');
          }

          CPOSL.data.bounds = liteTables.bounds || [];
          CPOSL.data.desirability = liteTables.desirability || [];
          CPOSL.data.weights = liteTables.weights || [];

          buildLiteIndexes();

          return getCPOSQuestionnaireConfig();
        })
        .then(function(qConfig) {
          console.log('[CPOS] getCPOSQuestionnaireConfig() result:', qConfig);

          if (qConfig && (qConfig.ok || qConfig.bank)) {
            CPOSL.q.bank = qConfig.bank || [];
            CPOSL.q.options = qConfig.options || [];
            CPOSL.q.derivationRules = qConfig.derivationRules || [];
            CPOSL.q.routingRules = qConfig.routingRules || [];
            CPOSL.q.signalToLiteMap = qConfig.signalToLiteMap || [];

            buildQuestionnaireIndexes();
          } else {
            console.warn('[CPOS] Questionnaire config not available');
            CPOSL.q.available = false;
          }

          buildFactorForm();
          updateQuestionnaireUIState();
          wireLanguageToggle();

          var factorCount = CPOSL.idx.boundsByVar.size;
          var qBankCount = CPOSL.q.idx.qBankById.size;
          var qReady = CPOSL.q.available;

          var statusMsg = 'Ready • Factors=' + factorCount + ' • QBank=' + qBankCount + (qReady ? ' ✓' : '');
          setStatus(factorCount > 0, statusMsg);

          console.log('[CPOS-Lite] init() complete:', {
            factors: factorCount,
            qBank: qBankCount,
            qReady: qReady
          });
        })
        .catch(function(err) {
          console.error('[CPOS-Lite] init() failed:', err);
          setStatus(false, 'Init failed: ' + (err && err.message ? err.message : err));
        });
    }

    // Start when DOM ready
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
