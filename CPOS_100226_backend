/***********************
 * CP-OS Lite Backend (DROP-IN)
 * âœ… Uses ONLY:
 *   - CPOS_Lite_Bounds
 *   - CPOS_Lite_Desirability
 *   - CPOS_Lite_Weights
 *
 * âŒ Does NOT read:
 *   - CPOS_Classes
 *   - CPOS_Rules
 *
 * Public API preserved:
 * - doGet()
 * - getCPOSData()           -> lite payload
 * - getCPOSData_Lite()      -> lite payload
 * - evaluateCPOS_v2()       -> delegates to lite evaluator
 * - evaluateCPOS_Lite_v1()  -> lite evaluator
 * - saveCPOSAssessment()
 * - cpos_upsertDraft()
 ***********************/

function doGet() {
  return HtmlService.createHtmlOutputFromFile('Index')
    .setTitle('CP-OS v1.1 DSS')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

function cpos_upsertDraft(p) {
  return cpos_upsertDraft_(p);
}


// âœ… SET THIS to your CPOS spreadsheet ID (the long string in the URL)
const CPOS_SS_ID = 'PASTE_YOUR_SPREADSHEET_ID_HERE';

function cpos_getSS_() {
  // Prefer container-bound active SS if present
  const active = SpreadsheetApp.getActiveSpreadsheet();
  if (active) return active;

  // Fallback to explicit ID for WebApp/standalone scripts
  if (CPOS_SS_ID && String(CPOS_SS_ID).trim()) {
    return SpreadsheetApp.openById(String(CPOS_SS_ID).trim());
  }

  throw new Error('No active spreadsheet. Set CPOS_SS_ID in Code.gs');
}


/** ---------- Utilities ---------- */

// âœ… Server API for frontend boot
function getCPOSLiteTables() {
  const warnings = [];
  const ctx = debugSpreadsheetContext();

  let bounds = { headers: [], rows: [], warnings: [] };
  let desir = { headers: [], rows: [], warnings: [] };
  let wts = { headers: [], rows: [], warnings: [] };

  try {
    bounds = cpos_getTableFast_('CPOS_Lite_Bounds', { allowMissing: false });
  } catch (err) {
    warnings.push(`CPOS_Lite_Bounds error: ${err.message || err}`);
  }

  try {
    desir = cpos_getTableFast_('CPOS_Lite_Desirability', { allowMissing: false });
  } catch (err) {
    warnings.push(`CPOS_Lite_Desirability error: ${err.message || err}`);
  }

  try {
    wts = cpos_getTableFast_('CPOS_Lite_Weights', { allowMissing: false });
  } catch (err) {
    warnings.push(`CPOS_Lite_Weights error: ${err.message || err}`);
  }

  if (bounds.warnings && bounds.warnings.length) warnings.push.apply(warnings, bounds.warnings);
  if (desir.warnings && desir.warnings.length) warnings.push.apply(warnings, desir.warnings);
  if (wts.warnings && wts.warnings.length) warnings.push.apply(warnings, wts.warnings);

  // âœ… Canonicalize keys so frontend ALWAYS sees Variable_Name, Class_Label, etc.
  const boundsRows = (bounds.rows || []).map(cpos_canonLiteBoundsRow_).filter(r => String(r.Variable_Name || '').trim());
  const desirRows = (desir.rows || []).map(cpos_canonLiteDesirRow_).filter(r => String(r.Variable_Name || '').trim());
  const wtsRows = (wts.rows || []).map(cpos_canonLiteWeightRow_).filter(r => String(r.Variable_Name || '').trim());

  // âœ… ok only if we actually have rows
  const ok = boundsRows.length > 0 && desirRows.length > 0 && wtsRows.length > 0;

  const meta = {
    spreadsheetId: ctx.id || null,
    spreadsheetName: ctx.name || null,
    bounds_rows: boundsRows.length,
    desirability_rows: desirRows.length,
    weights_rows: wtsRows.length,
    raw_bounds_rows: (bounds.rows || []).length,
    raw_desirability_rows: (desir.rows || []).length,
    raw_weights_rows: (wts.rows || []).length,
    bounds_headers: bounds.headers || [],
    desirability_headers: desir.headers || [],
    weights_headers: wts.headers || []
  };

  // optional computed maps (kept)
  let lite = { aspectsMap: {}, desirIdx: {}, wIdx: {} };
  try { lite = getCPOSData_Lite(); } catch (e) { warnings.push('getCPOSData_Lite failed: ' + (e?.message || e)); }

  return {
    ok,
    bounds: boundsRows,
    desirability: desirRows,
    weights: wtsRows,
    meta,
    warnings,
    aspectsMap: lite.aspectsMap || {},
    desirIdx: lite.desirIdx || {},
    wIdx: lite.wIdx || {}
  };
}


// âœ… Back-compat alias used by frontend
function saveCPOSLiteAssessment(payload) {
  return saveCPOSAssessment(payload);
}

function cpos_getSheet_(name) {
  const ss = cpos_getSS_();
  const sh = ss.getSheetByName(name);
  if (!sh) throw new Error(`Missing sheet: ${name}`);
  return sh;
}

function cpos_tryGetSheet_(name) {
  const ss = cpos_getSS_();
  return ss.getSheetByName(name) || null;
}

function cpos_findSheetByAliases_(names) {
  const ss = cpos_getSS_();
  const list = Array.isArray(names) ? names : [names];

  for (let i = 0; i < list.length; i++) {
    const n = String(list[i] || '').trim();
    if (!n) continue;
    const exact = ss.getSheetByName(n);
    if (exact) return exact;
  }

  const all = ss.getSheets();
  const norm = s => String(s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
  const wanted = list.map(norm).filter(Boolean);

  for (let i = 0; i < all.length; i++) {
    const sheet = all[i];
    const n = norm(sheet.getName());
    if (wanted.indexOf(n) >= 0) return sheet;
  }

  return null;
}

function debugSpreadsheetContext() {
  const ss = cpos_getSS_();
  return {
    id: ss.getId(),
    name: ss.getName(),
    sheets: ss.getSheets().map(s => s.getName())
  };
}



// TEMP DEBUG: inspect what the backend thinks are headers + row counts
function debugTablePeek(sheetName, limit) {
  limit = limit || 3;
  const tbl = cpos_getTableFast_(sheetName, { allowMissing: true });
  return {
    sheetName,
    headers: tbl.headers,
    rowCount: (tbl.rows || []).length,
    firstRows: (tbl.rows || []).slice(0, limit),
    warnings: tbl.warnings
  };
}



function cpos_nowISO_() {
  return new Date().toISOString();
}

function cpos_toBool_(v, defaultValue) {
  if (v === '' || v === null || v === undefined) {
    return (defaultValue === undefined) ? true : !!defaultValue;
  }
  if (typeof v === 'boolean') return v;
  const s = String(v).trim().toLowerCase();
  if (s === 'true' || s === 'yes' || s === '1') return true;
  if (s === 'false' || s === 'no' || s === '0') return false;
  return (defaultValue === undefined) ? true : !!defaultValue;
}

function cpos_parseDelimitedLine_(value, delimiter) {
  return String(value || '').split(delimiter).map(x => String(x || '').trim());
}

function cpos_getTableFast_(sheetName, opts) {
  opts = opts || {};
  const warnings = [];
  const sh = opts.allowMissing ? cpos_tryGetSheet_(sheetName) : cpos_getSheet_(sheetName);
  if (!sh) {
    warnings.push(`Missing sheet: ${sheetName}`);
    return { headers: [], rows: [], warnings };
  }

  const values = sh.getDataRange().getValues();
  if (!values || !values.length) {
    warnings.push(`Empty sheet: ${sheetName}`);
    return { headers: [], rows: [], warnings };
  }

  let rawHeaders = values[0] || [];
  let dataRows = values.slice(1);

  // Production-hardening: recover from TSV/CSV pasted into a single column.
  if (rawHeaders.length === 1) {
    const first = String(rawHeaders[0] || '');
    if (first.indexOf('	') >= 0 || first.indexOf(',') >= 0) {
      const delim = first.indexOf('	') >= 0 ? '	' : ',';
      rawHeaders = cpos_parseDelimitedLine_(first, delim);
      dataRows = dataRows.map(r => cpos_parseDelimitedLine_((r || [])[0], delim));
      warnings.push(`Detected ${delim === '	' ? 'TSV' : 'CSV'}-in-one-column format in sheet: ${sheetName}`);
    }
  }
  const headers = rawHeaders.map(h => String(h || '').trim());
  const headerIndex = headers
    .map((h, idx) => ({ h, idx }))
    .filter(item => item.h);

  if (!headerIndex.length) {
    warnings.push(`No headers found in sheet: ${sheetName}`);
    return { headers: [], rows: [], warnings };
  }
  const rows = [];

  for (let i = 0; i < dataRows.length; i++) {
    const r = dataRows[i] || [];
    let empty = true;
    const obj = {};
    for (let j = 0; j < headerIndex.length; j++) {
      const h = headerIndex[j].h;
      const v = r[headerIndex[j].idx];
      if (v !== '' && v !== null && v !== undefined) empty = false;
      obj[h] = v;
    }
    if (!empty) rows.push(obj);
  }

  return { headers: headerIndex.map(item => item.h), rows, warnings };
}

/** ---------- Constants (Lite) ---------- */

// Frontend results keys (keep your established keys)
const CPOS_PATHWAYS = ['RP-SOC', 'AWD-CHâ‚„', 'BIOCHAR', 'ERW'];

// Normalize pathway labels coming from Lite tables (Pathway column)
// (Supports your likely variants)
const CPOS_PATHWAY_ALIAS = {
  'rp-soc': 'RP-SOC',
  'rp soc': 'RP-SOC',
  'regenerative ag': 'RP-SOC',
  'regenerative agriculture': 'RP-SOC',
  'awd': 'AWD-CHâ‚„',
  'awd-ch4': 'AWD-CHâ‚„',
  'awd-châ‚„': 'AWD-CHâ‚„',
  'awd ch4': 'AWD-CHâ‚„',
  'biochar': 'BIOCHAR',
  'erw': 'ERW'
};

function cpos_normPathway_(p) {
  const k = String(p || '').trim().toLowerCase();
  return CPOS_PATHWAY_ALIAS[k] || String(p || '').trim();
}

function cpos_normKey_(s) {
  const v = String(s || '').normalize('NFKC');
  return v
    .trim()
    .replace(/\u00A0/g, ' ')
    .replace(/[â€“â€”]/g, '-')
    .replace(/\s+/g, ' ');
}

/** =========================================================
 * PUBLIC: Lite data for dropdowns + scoring indices
 * Returns:
 *  {
 *    ok: true,
 *    aspectsMap: {
 *      "<Variable_Name>": { category, factorId, classes:[...], classOrder:{...} }
 *    },
 *    desirIdx: { "Var|Class|Pathway": 0..1 },
 *    wIdx:     { "Var|Pathway": 0..10 }
 *  }
 * ========================================================= */
function getCPOSData_Lite() {
  const boundsTbl = cpos_getTableFast_('CPOS_Lite_Bounds', { allowMissing: true });
  const desirTbl = cpos_getTableFast_('CPOS_Lite_Desirability', { allowMissing: true });
  const wTbl = cpos_getTableFast_('CPOS_Lite_Weights', { allowMissing: true });

  // ---- aspectsMap from Bounds ----
  const aspectsMap = {};
  boundsTbl.rows.forEach(r => {
    const a = cpos_normKey_(r.Variable_Name);
    const c = cpos_normKey_(r.Class_Label);
    if (!a || !c) return;

    if (!aspectsMap[a]) {
      aspectsMap[a] = {
        category: cpos_normKey_(r.Factor_Category),
        factorId: cpos_normKey_(r.Factor_ID),
        classes: [],
        classOrder: {}
      };
    }

    if (!aspectsMap[a].classes.includes(c)) aspectsMap[a].classes.push(c);

    const ord = Number(r.Class_Order);
    if (!isNaN(ord)) aspectsMap[a].classOrder[c] = ord;
  });

  // Sort classes by Class_Order if present, else alpha
  Object.keys(aspectsMap).forEach(a => {
    const orderMap = aspectsMap[a].classOrder || {};
    aspectsMap[a].classes.sort((x, y) => {
      const ox = orderMap[x], oy = orderMap[y];
      if (ox !== undefined && oy !== undefined) return ox - oy;
      if (ox !== undefined) return -1;
      if (oy !== undefined) return 1;
      return String(x).localeCompare(String(y));
    });
  });

  // ---- desirability index ----
  // key: Variable_Name|Class_Label|Pathway -> desirability(0..1)
  const desirIdx = {};
  desirTbl.rows.forEach(r => {
    const a = cpos_normKey_(r.Variable_Name);
    const c = cpos_normKey_(r.Class_Label);
    const p = cpos_normPathway_(r.Pathway);

    const d = Number(r.Desirability_0_1);
    if (!a || !c || !p || isNaN(d)) return;

    desirIdx[`${a}|${c}|${p}`] = Math.max(0, Math.min(1, d));
  });

  // ---- weights index ----
  // key: Variable_Name|Pathway -> weight(0..10)
  const wIdx = {};
  wTbl.rows.forEach(r => {
    const a = cpos_normKey_(r.Variable_Name);
    const p = cpos_normPathway_(r.Pathway);

    const w = Number(r.Sensitivity_Weight_0_10);
    if (!a || !p || isNaN(w)) return;

    wIdx[`${a}|${p}`] = Math.max(0, Math.min(10, w));
  });

  return { ok: true, aspectsMap, desirIdx, wIdx };
}

/**
 * Back-compat wrapper:
 * Some frontends still call getCPOSData() and expect {ok, aspectsMap, rules?}
 * We return lite payload + rules:[]
 */
function getCPOSData(opts) {
  const lite = getCPOSData_Lite();
  return {
    ok: true,
    aspectsMap: lite.aspectsMap || {},
    desirIdx: lite.desirIdx || {},
    wIdx: lite.wIdx || {},
    rules: [] // legacy placeholder
  };
}

/**
 * PUBLIC: Lite evaluation WITH PATHWAY ELIGIBILITY CHECKS
 * ðŸ†• NOW CHECKS: MAIN_CROP, WATER_MANAGEMENT, BIOCHAR_APPLICATION, ERW_ROCK_TYPE signals
 * 
 * selections: { "<Variable_Name>": "<Class_Label>" | {Observed_Value, Class_Label}, ... }
 * opts.signals: { "<Signal_Key>": { value, confidence, sourceQ } }  â† ðŸ†• NEW PARAMETER
 * 
 * Returns:
 * { ok:true, selections, results, meta }
 */
function evaluateCPOS_Lite_v1(selections, opts) {
  if (!selections || typeof selections !== 'object') {
    throw new Error('evaluateCPOS_Lite_v1: selections missing');
  }

  opts = opts || {};
  const debug = opts.debug === true;

  // ðŸ†• NEW: Accept signals from questionnaire (passed from frontend)
  const signals = opts.signals || {};

  const data = getCPOSData_Lite();
  const desirIdx = data.desirIdx || {};
  const wIdx = data.wIdx || {};

  const results = {};
  CPOS_PATHWAYS.forEach(p => {
    results[p] = {
      eligibility: 'YES',
      priority: 'MEDIUM',
      mrv_tier: 'STANDARD',
      reasons: [],
      flags: [],
      final_text: '',
      mrv_variables: []
    };
  });

  const meta = { computed: 0, used: 0 };

  // Evaluate each pathway independently
  CPOS_PATHWAYS.forEach(pathway => {
    meta.computed++;

    let num = 0;
    let den = 0;
    const contributions = [];

    Object.keys(selections).forEach(varNameRaw => {
      const varName = cpos_normKey_(varNameRaw);
      const rawSelection = selections[varNameRaw];
      let clsValue = '';
      if (rawSelection && typeof rawSelection === 'object') {
        clsValue = rawSelection.Class_Label || rawSelection.classLabel || rawSelection.class_label || '';
      } else {
        clsValue = rawSelection;
      }

      const cls = cpos_normKey_(clsValue);
      if (!varName || !cls) return;

      const w = Number(wIdx[`${varName}|${pathway}`] || 0);
      if (!w) return;

      const d = Number(desirIdx[`${varName}|${cls}|${pathway}`]);
      if (isNaN(d)) return;

      num += (w * d);
      den += w;

      contributions.push({ varName, cls, w, d, wd: (w * d) });
      meta.used++;
    });

    // Normalized score
    const score = (den > 0) ? (100 * (num / den)) : 0;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ðŸ†• PATHWAY-SPECIFIC ELIGIBILITY CHECKS (NEW LOGIC)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    let eligibility = 'YES';
    const eligibilityReasons = [];

    if (pathway === 'AWD-CHâ‚„') {
      // AWD Eligibility Requirements:
      // 1. Must be growing flooded rice
      // 2. Must use continuous flooding (baseline) - NOT already practicing AWD

      const mainCrop = signals['MAIN_CROP']?.value || '';
      const waterMgmt = signals['WATER_MANAGEMENT']?.value || '';

      Logger.log('[AWD Check] MAIN_CROP=' + mainCrop + ', WATER_MANAGEMENT=' + waterMgmt);

      if (!mainCrop) {
        eligibility = 'UNKNOWN';
        eligibilityReasons.push('Crop type unknown - need to ask main crop question');
      } else if (mainCrop !== 'RICE_FLOODED' && mainCrop !== 'RICE-FLOODED' &&
        !String(mainCrop).toLowerCase().includes('rice') ||
        String(mainCrop).toLowerCase().includes('aerobic')) {
        eligibility = 'NO';
        eligibilityReasons.push('AWD pathway only applicable for flooded rice. Your crop: ' + mainCrop);
      } else if (!waterMgmt) {
        eligibility = 'UNKNOWN';
        eligibilityReasons.push('Water management unknown - need to ask Q_M049');
      } else if (waterMgmt === 'AWD_MILD' || waterMgmt === 'AWD_SEVERE' ||
        String(waterMgmt).toLowerCase().includes('awd')) {
        eligibility = 'NO';
        eligibilityReasons.push('Already practicing AWD (no additionality). Baseline required: continuous flooding');
      } else if (waterMgmt === 'CONTINUOUS_FLOOD' || waterMgmt === 'CONTINUOUS-FLOOD' ||
        String(waterMgmt).toLowerCase().includes('continuous')) {
        eligibility = 'YES'; // âœ… Eligible!
        eligibilityReasons.push('âœ… Eligible: Flooded rice with continuous flooding baseline');
      } else {
        eligibility = 'CONDITIONAL';
        eligibilityReasons.push('Uncertain baseline - verify flooding practice');
      }
    }

    else if (pathway === 'BIOCHAR') {
      // BIOCHAR Eligibility Requirements:
      // 1. Must be applying biochar to soil

      const biocharApp = signals['BIOCHAR_APPLICATION']?.value || '';

      Logger.log('[BIOCHAR Check] BIOCHAR_APPLICATION=' + biocharApp);

      if (!biocharApp) {
        eligibility = 'UNKNOWN';
        eligibilityReasons.push('Biochar application status unknown - need to ask Q_M055');
      } else if (biocharApp === 'YES' || String(biocharApp).toLowerCase() === 'yes') {
        eligibility = 'YES'; // âœ… Eligible!
        eligibilityReasons.push('âœ… Eligible: Applying biochar to soil');
      } else if (biocharApp === 'PLANNING') {
        eligibility = 'CONDITIONAL';
        eligibilityReasons.push('Planning to apply biochar - eligible once applied');
      } else {
        eligibility = 'NO';
        eligibilityReasons.push('Not applying biochar - must apply biochar for this pathway');
      }
    }

    else if (pathway === 'ERW') {
      // ERW Eligibility Requirements:
      // 1. Must be applying rock powder amendments (basalt, olivine, or other silicates)

      const erwRock = signals['ERW_ROCK_TYPE']?.value || '';

      Logger.log('[ERW Check] ERW_ROCK_TYPE=' + erwRock);

      if (!erwRock) {
        eligibility = 'UNKNOWN';
        eligibilityReasons.push('Rock amendment status unknown - need to ask Q_M060');
      } else if (erwRock === 'NONE' || String(erwRock).toLowerCase() === 'none') {
        eligibility = 'NO';
        eligibilityReasons.push('Not applying rock amendments - must apply basalt/olivine for ERW pathway');
      } else if (erwRock === 'BASALT' || erwRock === 'OLIVINE') {
        eligibility = 'YES'; // âœ… Eligible!
        eligibilityReasons.push('âœ… Eligible: Applying ' + erwRock + ' rock powder (ideal for ERW)');
      } else if (erwRock === 'OTHER') {
        eligibility = 'CONDITIONAL';
        eligibilityReasons.push('Applying rock powder - verify it is silicate-based (basalt/olivine preferred)');
      } else {
        eligibility = 'YES';
        eligibilityReasons.push('Applying rock amendment: ' + erwRock);
      }
    }

    else if (pathway === 'RP-SOC') {
      // RP-SOC is universal (no crop-specific requirements)
      // Eligibility based on score and data availability
      if (den === 0) {
        eligibility = 'CONDITIONAL';
        eligibilityReasons.push('Insufficient data - need soil/management inputs');
      } else {
        eligibility = 'YES';
        eligibilityReasons.push('Regenerative agriculture pathway (soil carbon sequestration)');
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // END ELIGIBILITY CHECKS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Priority banding (tune if you want)
    let priority = 'MEDIUM';
    if (eligibility === 'NO') {
      priority = 'EXCLUDED';
    } else if (eligibility === 'UNKNOWN' || eligibility === 'CONDITIONAL') {
      priority = 'LOW';
    } else if (score >= 70) {
      priority = 'HIGH';
    } else if (score < 45) {
      priority = 'LOW';
    }

    // MRV tier proxy: count high-importance drivers used
    const highW = contributions.filter(x => x.w >= 7).length;
    let mrv_tier = 'STANDARD';
    if (eligibility === 'NO' || eligibility === 'UNKNOWN') {
      mrv_tier = 'N/A';
    } else if (eligibility === 'CONDITIONAL') {
      mrv_tier = 'HIGH';
    } else if (highW >= 4) {
      mrv_tier = 'HIGH';
    } else if (highW <= 1) {
      mrv_tier = 'LIGHT';
    }

    // Explanations
    contributions.sort((a, b) => (b.wd - a.wd));
    const top = contributions.slice(0, 3);

    const reasons = [];

    // ðŸ†• Add eligibility reasons FIRST
    eligibilityReasons.forEach(r => reasons.push(r));

    // Then add scoring details
    if (eligibility === 'YES' || eligibility === 'CONDITIONAL') {
      reasons.push(`Score = ${score.toFixed(1)} / 100 (normalized).`);
      if (priority === 'HIGH') {
        reasons.push('High suitability under current factor context.');
      } else if (priority === 'LOW') {
        reasons.push('Low suitability under current factor context.');
      } else if (priority === 'MEDIUM') {
        reasons.push('Moderate suitability under current factor context.');
      }

      if (top.length) {
        reasons.push('Top drivers: ' + top.map(x => `${x.varName}: ${x.cls} (w=${x.w}, d=${x.d})`).join(' | '));
      }
    }

    const final_text =
      eligibility === 'NO'
        ? `Not eligible for ${pathway}. ${eligibilityReasons.join(' ')}`
        : eligibility === 'UNKNOWN'
          ? `Eligibility unknown for ${pathway}. ${eligibilityReasons.join(' ')}`
          : `Normalized suitability score is ${score.toFixed(1)}/100 using weights (0â€“10) and desirability (0â€“1). ` +
          (top.length ? (`Key drivers: ${top.map(x => `${x.varName}=${x.cls}`).join('; ')}.`) : '');

    results[pathway] = {
      eligibility,
      priority,
      mrv_tier,
      score: score.toFixed(1), // ðŸ†• NEW: Include score in results
      reasons: reasons.slice(0, 5), // Increased from 4 to 5 to include eligibility reason
      flags: [],
      final_text,
      mrv_variables: []
    };
  });

  const resp = { ok: true, selections, results };
  if (debug) resp.meta = meta;
  return resp;
}


/**
 * Back-compat wrapper:
 * If your frontend still calls evaluateCPOS_v2(), keep it working.
 */
function evaluateCPOS_v2(selections, opts) {
  return evaluateCPOS_Lite_v1(selections, opts || {});
}

/** =========================================================
 * Save assessment (unchanged)
 * payload = { clientId, siteId, siteName, lat, lon, cropSystem, state, district, selections, inputs, results, notes }
 ** ========================================================= */
function saveCPOSAssessment(payload) {
  payload = payload || {};
  const sh = cpos_getSheet_('CPOS_Assessments');

  const assessmentId = payload.Assessment_ID || ('CPOS-' + Utilities.getUuid().slice(0, 8).toUpperCase());
  const createdAt = payload.Created_At || cpos_nowISO_();
  const createdBy = payload.Created_By || Session.getActiveUser().getEmail() || 'unknown';
  const selections = payload.selections || payload.inputs || {};

  const row = {
    Assessment_ID: assessmentId,
    Created_At: createdAt,
    Created_By: createdBy,
    Client_ID: payload.Client_ID || payload.clientId || 'Default',
    Site_ID: payload.Site_ID || payload.siteId || '',
    Site_Name: payload.Site_Name || payload.siteName || '',
    Latitude: payload.Latitude || payload.lat || '',
    Longitude: payload.Longitude || payload.lon || '',
    Crop_System: payload.Crop_System || payload.cropSystem || '',
    State: payload.State || payload.state || '',
    District: payload.District || payload.district || '',
    Selected_Classes_JSON: JSON.stringify(selections || {}),
    Pathway_Results_JSON: JSON.stringify(payload.results || {}),
    Top_Reasons_JSON: JSON.stringify(payload.topReasons || {}),
    Risk_Flags_JSON: JSON.stringify(payload.riskFlags || []),
    MRV_Plan_JSON: JSON.stringify(payload.mrvPlan || {}),
    Notes: payload.Notes || payload.notes || ''
  };

  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(h => String(h || '').trim());
  const out = headers.map(h => row[h] !== undefined ? row[h] : '');
  sh.appendRow(out);

  return { ok: true, Assessment_ID: assessmentId };
}

/** =========================================================
 * Draft upsert (unchanged)
 * ========================================================= */
function cpos_upsertDraft_(p) {
  if (!p || !p.sessionId) throw new Error('Draft: sessionId missing');

  const sh = cpos_getSheet_('CPOS_Drafts');

  const values = sh.getDataRange().getValues();
  if (!values || !values.length) throw new Error('CPOS_Drafts: missing header row');

  const headers = values[0].map(h => String(h || '').trim());

  const idxSession = headers.indexOf('Session_ID');
  const idxUpdated = headers.indexOf('Updated_At');
  const idxSelJson = headers.indexOf('Selections_JSON');
  const idxSelHuman = headers.indexOf('Selections_Human');
  const idxCreated = headers.indexOf('Created_At');

  if (idxSession < 0 || idxUpdated < 0 || idxSelJson < 0) {
    throw new Error('CPOS_Drafts missing required headers: Session_ID, Updated_At, Selections_JSON');
  }

  const now = cpos_nowISO_();
  const selections = p.selections || {};
  const selJson = JSON.stringify(selections);
  const selHuman = Object.keys(selections).map(k => `${k}: ${selections[k]}`).join(' | ');

  // update existing
  for (let i = 1; i < values.length; i++) {
    if (String(values[i][idxSession] || '') === String(p.sessionId)) {
      if (idxUpdated >= 0) sh.getRange(i + 1, idxUpdated + 1).setValue(now);
      if (idxSelJson >= 0) sh.getRange(i + 1, idxSelJson + 1).setValue(selJson);
      if (idxSelHuman >= 0) sh.getRange(i + 1, idxSelHuman + 1).setValue(selHuman);
      return { ok: true, updated: true };
    }
  }

  // append new
  const out = headers.map(h => {
    if (h === 'Draft_ID') return 'DRAFT-' + Utilities.getUuid();
    if (h === 'Session_ID') return String(p.sessionId);
    if (h === 'Created_At') return now;
    if (h === 'Updated_At') return now;
    if (h === 'Selections_JSON') return selJson;
    if (h === 'Selections_Human') return selHuman;
    return '';
  });

  sh.appendRow(out);
  return { ok: true, created: true };
}


function cpos_getTableByAliases_(names) {
  const warnings = [];
  const sh = cpos_findSheetByAliases_(names);
  if (!sh) {
    warnings.push('Missing sheet (aliases): ' + (Array.isArray(names) ? names.join(' | ') : names));
    return { headers: [], rows: [], warnings, sheetName: '' };
  }
  const tbl = cpos_getTableFast_(sh.getName(), { allowMissing: false });
  tbl.sheetName = sh.getName();
  return tbl;
}


/**
 * PUBLIC: getCPOSQuestionnaireConfig()
 * Returns questionnaire config + Bounds classes for mapping validation.
 */
function getCPOSQuestionnaireConfig() {
  try {
    const bank = cpos_getTableByAliases_(['CPOS_Q_Bank', 'CPOS_QBank']);
    const opts = cpos_getTableByAliases_(['CPOS_Q_Options', 'CPOS_QOptions']);
    const deriv = cpos_getTableByAliases_(['CPOS_Q_Derivation_Rules', 'CPOS_Q_DerivationRules']);
    const routes = cpos_getTableByAliases_(['CPOS_Q_Routing_Rules', 'CPOS_Q_RoutingRules']);
    const map = cpos_getTableByAliases_(['CPOS_Q_Signal_to_LiteFactor_Map', 'CPOS_Q_SignaltoLiteFactorMap']);
    const bounds = cpos_getTableByAliases_(['CPOS_Lite_Bounds']);

    const normalizedBank = normalizeQuestionnaireFields(bank.rows || []);
    const normalizedOpts = normalizeQuestionnaireFields(opts.rows || []);
    const normalizedDeriv = normalizeQuestionnaireFields(deriv.rows || []);
    const normalizedRoutes = normalizeQuestionnaireFields(routes.rows || []);
    const normalizedMap = normalizeQuestionnaireFields(map.rows || []);
    const normalizedBounds = normalizeQuestionnaireFields(bounds.rows || []);

    const warnings = []
      .concat(bank.warnings || [])
      .concat(opts.warnings || [])
      .concat(deriv.warnings || [])
      .concat(routes.warnings || [])
      .concat(map.warnings || [])
      .concat(bounds.warnings || []);

    if ((normalizedBank || []).length && !normalizedBank.some(r => String(r.QuestionID || r.Question_ID || '').trim())) {
      warnings.push('CPOS_Q_Bank rows found but no QuestionID/Question_ID values were recognized. Check header spelling.');
    }

    return {
  ok: true,
  bank: normalizedBank,
  options: normalizedOpts,
  derivationRules: normalizedDeriv,
  routingRules: normalizedRoutes,
  signalToLiteMap: normalizedMap,

  // âœ… back-compat: some frontends expect liteBounds
  bounds: normalizedBounds,
  liteBounds: normalizedBounds,

  warnings,
  meta: {
    bankRows: normalizedBank.length,
    optionsRows: normalizedOpts.length,
    derivRows: normalizedDeriv.length,
    routesRows: normalizedRoutes.length,
    signalMapRows: normalizedMap.length,
    boundsRows: normalizedBounds.length
  }
};


  } catch (e) {
    return {
      ok: false,
      error: String(e?.message || e || ''),
      bank: [],
      options: [],
      derivationRules: [],
      routingRules: [],
      signalToLiteMap: [],
      bounds: [],
      liteBounds: [],
      warnings: ['getCPOSQuestionnaireConfig failed: ' + String(e?.message || e || '')],
      meta: null
    };
  }
}


// TEMP DEBUG: prove what getCPOSQuestionnaireConfig() is actually returning
function debugQuestionnaireConfigReturn() {
  const res = getCPOSQuestionnaireConfig();
  return {
    ok: res?.ok,
    bankLen: Array.isArray(res?.bank) ? res.bank.length : -1,
    optionsLen: Array.isArray(res?.options) ? res.options.length : -1,
    derivLen: Array.isArray(res?.derivationRules) ? res.derivationRules.length : -1,
    routesLen: Array.isArray(res?.routingRules) ? res.routingRules.length : -1,
    signalMapLen: Array.isArray(res?.signalToLiteMap) ? res.signalToLiteMap.length : -1,
    liteBoundsLen: Array.isArray(res?.liteBounds) ? res.liteBounds.length : -1,
    warnings: res?.warnings || [],
    meta: res?.meta || null,
    // tiny sample to verify field names coming through
    bankFirst: Array.isArray(res?.bank) && res.bank[0] ? Object.keys(res.bank[0]).slice(0, 15) : null
  };
}




/**
 * PUBLIC: saveCPOSQuestionnaireSession(payload)
 * payload = {
 *   session: { Session_ID?, Client_ID?, Site_ID?, Site_Name?, Mode?, Min_Q_Target?, Max_Q_Cap?, Status? },
 *   responses: [ { Question_ID, Answer_Raw, Answer_Normalized?, Derived_Signals_JSON? } ],
 *   signals:   [ { Signal_Key, Signal_Value, Confidence?, Source? } ],
 *   summary:   { ... }   // optional
 * }
 */
function saveCPOSQuestionnaireSession(payload) {
  payload = payload || {};
  const now = cpos_nowISO_();
  const user = Session.getActiveUser().getEmail() || 'unknown';

  const sess = payload.session || {};
  const sessionId = sess.Session_ID || ('Q-' + Utilities.getUuid().slice(0, 10).toUpperCase());
  const version = sess.Version || payload.version || 'v1';

  // --- upsert session ---
  const shS = cpos_getSheet_('CPOS_Q_Sessions');
  const sVals = shS.getDataRange().getValues();
  if (!sVals || !sVals.length) throw new Error('CPOS_Q_Sessions: missing header row');
  const sHdr = sVals[0].map(h => String(h || '').trim());
  const idxSid = sHdr.indexOf('Session_ID');
  if (idxSid < 0) throw new Error('CPOS_Q_Sessions: missing Session_ID');

  // âœ… FIX: Extract probe data
  const responses = Array.isArray(payload.responses) ? payload.responses : [];
  const probeResponses = responses.filter(r => r.IsProbe || r.Is_Probe);
  const probeCount = probeResponses.length;

  // Calculate average confidence
  let totalConf = 0;
  let confCount = 0;
  responses.forEach(r => {
    const conf = parseFloat(r.Confidence_0_1 || r.ConfidenceBoost || 0);
    if (conf > 0) {
      totalConf += conf;
      confCount++;
    }
  });
  const avgConfidence = confCount > 0 ? (totalConf / confCount) : 0.85;

  // Get probe IDs that were triggered
  const probeTriggered = probeResponses
    .map(r => String(r.Question_ID || r.QuestionID || '').replace('PROBE_', ''))
    .filter(Boolean)
    .join(',');

  const rowObj = {
    Session_ID: sessionId,
    Created_At: sess.Created_At || now,
    Created_By: sess.Created_By || user,
    Client_ID: sess.Client_ID || 'Default',
    Site_ID: sess.Site_ID || '',
    Site_Name: sess.Site_Name || '',
    Mode: sess.Mode || 'BASIC',
    Min_Target: sess.Min_Target || sess.Min_Q_Target || 20,
    Max_Cap: sess.Max_Cap || sess.Max_Q_Cap || 50,
    Answered_Count: sess.Answered_Count || responses.length || 0,
    Probe_Count: probeCount, // âœ… NEW
    Probe_Triggered: probeTriggered, // âœ… NEW
    Avg_Confidence: avgConfidence, // âœ… NEW
    Status: sess.Status || 'COMPLETED',
    Summary_JSON: JSON.stringify(payload.summary || {}),
    Version: version
  };

  let updated = false;
  for (let i = 1; i < sVals.length; i++) {
    if (String(sVals[i][idxSid] || '') === String(sessionId)) {
      const out = sHdr.map(h => rowObj[h] !== undefined ? rowObj[h] : sVals[i][sHdr.indexOf(h)]);
      shS.getRange(i + 1, 1, 1, sHdr.length).setValues([out]);
      updated = true;
      break;
    }
  }
  if (!updated) {
    shS.appendRow(sHdr.map(h => rowObj[h] !== undefined ? rowObj[h] : ''));
  }

  // --- append responses ---
  const shR = cpos_getSheet_('CPOS_Q_Responses');
  const rHdr = shR.getRange(1, 1, 1, shR.getLastColumn()).getValues()[0].map(h => String(h || '').trim());

  if (responses.length) {
    const rows = responses.map(r => {
      const rr = {
        Session_ID: sessionId,
        Answered_At: now,
        Question_ID: r.Question_ID || r.QuestionID || '',
        Answer_Raw: r.Answer_Raw || r.AnswerRaw !== undefined ? String(r.Answer_Raw || r.AnswerRaw) : '',
        Answer_Codes: r.Answer_Codes || r.AnswerCodes ? String(r.Answer_Codes || r.AnswerCodes) : '',
        Is_Probe: r.Is_Probe || r.IsProbe || false, // âœ… NEW
        Probe_Reason: r.Probe_Reason || r.ProbeReason || '', // âœ… NEW
        Confidence_Boost: r.Confidence_Boost || r.ConfidenceBoost || 0, // âœ… NEW
        Derived_Signals_JSON: r.Derived_Signals_JSON ? String(r.Derived_Signals_JSON) : '',
        Version: version
      };
      return rHdr.map(h => rr[h] !== undefined ? rr[h] : '');
    });

    shR.getRange(shR.getLastRow() + 1, 1, rows.length, rHdr.length).setValues(rows);
  }

  Logger.log('âœ… Questionnaire session saved: ' + sessionId + ', Probes: ' + probeCount); // âœ… NEW log

  return { ok: true, Session_ID: sessionId, updated };
}



/** =========================================================
 * Validation + sample tests
 * ========================================================= */
function TEST_validateLiteTables() {
  const bounds = cpos_getTableFast_('CPOS_Lite_Bounds', { allowMissing: true });
  const desir = cpos_getTableFast_('CPOS_Lite_Desirability', { allowMissing: true });
  const weights = cpos_getTableFast_('CPOS_Lite_Weights', { allowMissing: true });

  const warnings = [];
  const errors = [];

  const requiredBounds = ['Factor_ID', 'Factor_Category', 'Variable_Name', 'Factor_Display_Name', 'Class_Order', 'Class_Label', 'Lower_Bound', 'Upper_Bound', 'Lower_Inclusive', 'Upper_Inclusive', 'Unit'];
  const requiredDesir = ['Variable_Name', 'Class_Label', 'Pathway', 'Desirability_0_1', 'Shape', 'Pathway_Context'];
  const requiredWeights = ['Variable_Name', 'Pathway', 'Sensitivity_Weight_0_10'];

  function missingCols(required, headers) {
    return required.filter(h => headers.indexOf(h) < 0);
  }

  const boundsMissing = missingCols(requiredBounds, bounds.headers || []);
  const desirMissing = missingCols(requiredDesir, desir.headers || []);
  const weightsMissing = missingCols(requiredWeights, weights.headers || []);

  if (boundsMissing.length) errors.push(`Bounds missing headers: ${boundsMissing.join(', ')}`);
  if (desirMissing.length) errors.push(`Desirability missing headers: ${desirMissing.join(', ')}`);
  if (weightsMissing.length) errors.push(`Weights missing headers: ${weightsMissing.join(', ')}`);

  const boundsMap = {};
  const classOrderMap = {};

  (bounds.rows || []).forEach(r => {
    const varName = cpos_normKey_(r.Variable_Name);
    const classLabel = cpos_normKey_(r.Class_Label);
    if (!varName || !classLabel) return;

    if (!boundsMap[varName]) boundsMap[varName] = new Set();
    boundsMap[varName].add(classLabel);

    const order = Number(r.Class_Order);
    if (!isNaN(order)) {
      const key = `${varName}|${order}`;
      if (classOrderMap[key]) {
        errors.push(`Duplicate Class_Order ${order} for Variable_Name ${varName}`);
      } else {
        classOrderMap[key] = true;
      }
    }

    const lo = Number(r.Lower_Bound);
    const hi = Number(r.Upper_Bound);
    if (!isNaN(lo) && !isNaN(hi) && lo > hi) {
      errors.push(`Bounds invalid for ${varName} (${classLabel}): Lower_Bound > Upper_Bound`);
    }
  });

  (desir.rows || []).forEach(r => {
    const varName = cpos_normKey_(r.Variable_Name);
    const classLabel = cpos_normKey_(r.Class_Label);
    const d = Number(r.Desirability_0_1);

    if (!varName || !classLabel) return;
    if (!boundsMap[varName]) {
      warnings.push(`Desirability Variable_Name not in Bounds: ${varName}`);
    } else if (!boundsMap[varName].has(classLabel)) {
      warnings.push(`Desirability Class_Label not in Bounds: ${varName} -> ${classLabel}`);
    }

    if (isNaN(d) || d < 0 || d > 1) {
      errors.push(`Desirability_0_1 out of range for ${varName} (${classLabel})`);
    }
  });

  (weights.rows || []).forEach(r => {
    const varName = cpos_normKey_(r.Variable_Name);
    const w = Number(r.Sensitivity_Weight_0_10);

    if (varName && !boundsMap[varName]) {
      warnings.push(`Weights Variable_Name not in Bounds: ${varName}`);
    }

    if (isNaN(w) || w < 0 || w > 10) {
      errors.push(`Sensitivity_Weight_0_10 out of range for ${varName}`);
    }
  });

  Logger.log('TEST_validateLiteTables results');
  Logger.log('Errors: ' + JSON.stringify(errors));
  Logger.log('Warnings: ' + JSON.stringify(warnings));
  Logger.log('Counts: bounds=' + (bounds.rows || []).length + ', desir=' + (desir.rows || []).length + ', weights=' + (weights.rows || []).length);
}

function TEST_sampleEvaluation() {
  const bounds = cpos_getTableFast_('CPOS_Lite_Bounds', { allowMissing: true });
  const selections = {};

  const byVar = {};
  (bounds.rows || []).forEach(r => {
    const varName = cpos_normKey_(r.Variable_Name);
    const classLabel = cpos_normKey_(r.Class_Label);
    if (!varName || !classLabel) return;
    if (!byVar[varName]) byVar[varName] = classLabel;
  });

  Object.keys(byVar).slice(0, 3).forEach(k => {
    selections[k] = byVar[k];
  });

  Logger.log('TEST_sampleEvaluation selections=' + JSON.stringify(selections));
  const r = evaluateCPOS_Lite_v1(selections, { debug: true });
  Logger.log(JSON.stringify(r, null, 2));
}


function saveCPOSSession(payload) {
  const ss = cpos_getSS_();

  // Save session with probe data
  let sessionSheet = ss.getSheetByName('CPOS_Sessions');
  if (!sessionSheet) {
    sessionSheet = ss.insertSheet('CPOS_Sessions');
    sessionSheet.appendRow(['SessionID', 'Timestamp', 'Mode', 'MinTarget',
      'MaxCap', 'AnsweredCount', 'ProbeCount',
      'ProbeTriggered', 'AvgConfidence', 'Status']);
  }

  const session = payload.session || {};
  const probeIds = payload.responses
    .filter(r => r.IsProbe)
    .map(r => r.QuestionID.replace('PROBE_', ''))
    .join(',');

  sessionSheet.appendRow([
    session.SessionID,
    new Date(),
    session.Mode || 'BASIC',
    session.MinTarget || 20,
    session.MaxCap || 50,
    session.AnsweredCount || 0,
    session.ProbeCount || 0,
    probeIds || '',
    payload.avgConfidence || 0.85,
    session.Status || 'COMPLETED'
  ]);

  // Save responses with probe metadata
  let responseSheet = ss.getSheetByName('CPOS_Responses');
  if (!responseSheet) {
    responseSheet = ss.insertSheet('CPOS_Responses');
    responseSheet.appendRow(['SessionID', 'Timestamp', 'QuestionID',
      'AnswerRaw', 'AnswerCodes', 'IsProbe',
      'ProbeReason', 'ConfidenceBoost']);
  }

  const responses = payload.responses || [];
  responses.forEach(function (resp) {
    responseSheet.appendRow([
      session.SessionID,
      new Date(),
      resp.QuestionID,
      resp.AnswerRaw || '',
      resp.AnswerCodes || '',
      resp.IsProbe || false,
      resp.ProbeReason || '',
      resp.ConfidenceBoost || 0
    ]);
  });

  Logger.log('Session saved: ' + session.SessionID + ', Probes: ' + (session.ProbeCount || 0));

  return {
    success: true,
    sessionId: session.SessionID,
    timestamp: new Date().toISOString()
  };
}


/**
 * Normalize snake_case field names to PascalCase for frontend
 */
function normalizeQuestionnaireFields(data) {
  const fieldMap = {
    // ---------------- Question fields ----------------
    'Question_ID': 'QuestionID',
    'Question_Text': 'QuestionTextEN',     // fallback (no lang suffix)
    'Help_Text': 'HelpTextEN',             // fallback (no lang suffix)

    'Question_Text_EN': 'QuestionTextEN',
    'Question_Text_HI': 'QuestionTextHI',
    'Answer_Type': 'AnswerType',
    'Help_Text_EN': 'HelpTextEN',
    'Help_Text_HI': 'HelpTextHI',
    'Is_Active': 'IsActive',
    'Is_Required': 'IsRequired',
    'Min_Answers': 'MinAnswers',
    'Max_Answers': 'MaxAnswers',
    'Group_Code': 'GroupCode',
    'Factor_Code': 'FactorCode',
    'Base_Priority': 'BasePriority',
    'Units_Label': 'UnitsLabel',
    'Confidentiality_Tag': 'ConfidentialityTag',
    'Context_Template': 'ContextTemplate',

    // These exist in your Q_Bank table (you showed Mode, Sequence)
    'Mode': 'Mode',
    'Sequence': 'Sequence',
    'Domain': 'Domain',
    'Group_Code': 'GroupCode',

    // ---------------- Option fields ----------------
    'Option_ID': 'OptionID',
    'Option_Code': 'OptionCode',
    'Option_Order': 'OptionOrder',

    // If you have only one label column, treat as EN
    'Option_Label': 'OptionLabelEN',
    'Option_Label_EN': 'OptionLabelEN',
    'Option_Label_HI': 'OptionLabelHI',

    // ---------------- Derivation rule fields ----------------
    'Rule_ID': 'RuleID',
    'When_Question_ID': 'WhenQuestionID',
    'When_Operator': 'WhenOperator',
    'When_Value': 'WhenValue',
    'Then_Signal_Key': 'ThenSignalKey',
    'Then_Signal_Value': 'ThenSignalValue',
    'Then_Signal_Score': 'ThenSignalScore',

    // ---------------- Routing rule fields ----------------
    'Route_ID': 'RouteID',
    'Current_Question_ID': 'CurrentQuestionID',
    'Next_Question_ID': 'NextQuestionID',
    'Condition_Signal_Key': 'ConditionSignalKey',
    'Condition_Operator': 'ConditionOperator',
    'Condition_Value': 'ConditionValue',
    'Route_Action': 'RouteAction',

    // ---------------- Signal mapping fields ----------------
    'Signal_Key': 'SignalKey',
    'Lite_Variable_Name': 'LiteVariableName',
    'Mapping_Method': 'MappingMethod',
    'When_Signal_Value': 'WhenSignalValue',
    'Then_Lite_Class': 'ThenLiteClass',
    'Estimate_Formula': 'EstimateFormula',

    // ---------------- Bounds fields ----------------
    'Variable_Name': 'VariableName',
    'Factor_ID': 'FactorID',
    'Factor_Category': 'FactorCategory',
    'Factor_Display_Name': 'FactorDisplayName',
    'Class_Label': 'ClassLabel',
    'Class_Order': 'ClassOrder',
    'Lower_Bound': 'LowerBound',
    'Upper_Bound': 'UpperBound',
    'Lower_Inclusive': 'LowerInclusive',
    'Upper_Inclusive': 'UpperInclusive'
  };

  // Fuzzy-key map (normalizeFieldKey_ must exist)
  const normalizedFieldMap = {};
  Object.keys(fieldMap).forEach(k => {
    normalizedFieldMap[normalizeFieldKey_(k)] = fieldMap[k];
  });

  if (!Array.isArray(data)) return data;

  return data.map(row => {
    const normalized = {};
    for (const [oldKey, value] of Object.entries(row || {})) {
      const direct = fieldMap[oldKey];
      const fuzzy = normalizedFieldMap[normalizeFieldKey_(oldKey)];
      const newKey = direct || fuzzy || oldKey;
      normalized[newKey] = value;
    }

    // ---- fallbacks for key identifiers ----
    if (!String(normalized.QuestionID || '').trim()) {
      normalized.QuestionID =
        cpos_pickField_(row, ['Question_ID', 'QuestionID', 'Question Id', 'question_id']) ||
        cpos_guessQuestionId_(row);
    }
    if (!String(normalized.WhenQuestionID || '').trim()) {
      normalized.WhenQuestionID = cpos_pickField_(row, ['When_Question_ID', 'WhenQuestionID', 'When Question ID']);
    }
    if (!String(normalized.CurrentQuestionID || '').trim()) {
      normalized.CurrentQuestionID = cpos_pickField_(row, ['Current_Question_ID', 'CurrentQuestionID', 'Current Question ID']);
    }
    if (!String(normalized.SignalKey || '').trim()) {
      normalized.SignalKey = cpos_pickField_(row, ['Signal_Key', 'SignalKey', 'Signal Key']);
    }

    // ---- Back-compat: snake_case mirrors (only if missing) ----
    if (normalized.QuestionID && normalized.Question_ID === undefined) normalized.Question_ID = normalized.QuestionID;

    if (normalized.QuestionTextEN && normalized.Question_Text_EN === undefined) normalized.Question_Text_EN = normalized.QuestionTextEN;
    if (normalized.QuestionTextHI && normalized.Question_Text_HI === undefined) normalized.Question_Text_HI = normalized.QuestionTextHI;

    if (normalized.HelpTextEN && normalized.Help_Text_EN === undefined) normalized.Help_Text_EN = normalized.HelpTextEN;
    if (normalized.HelpTextHI && normalized.Help_Text_HI === undefined) normalized.Help_Text_HI = normalized.HelpTextHI;

    if (normalized.AnswerType && normalized.Answer_Type === undefined) normalized.Answer_Type = normalized.AnswerType;

    if (normalized.IsActive !== undefined && normalized.Is_Active === undefined) normalized.Is_Active = normalized.IsActive;
    if (normalized.IsRequired !== undefined && normalized.Is_Required === undefined) normalized.Is_Required = normalized.IsRequired;

    // Options mirrors (if any old code expects snake_case)
    if (normalized.OptionID && normalized.Option_ID === undefined) normalized.Option_ID = normalized.OptionID;
    if (normalized.OptionCode && normalized.Option_Code === undefined) normalized.Option_Code = normalized.OptionCode;

    return normalized;
  });
}


function normalizeFieldKey_(key) {
  return String(key || '')
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '');
}

function cpos_pickField_(row, candidates) {
  if (!row || typeof row !== 'object') return '';

  for (let i = 0; i < candidates.length; i++) {
    const c = candidates[i];
    if (row[c] !== undefined && row[c] !== null && String(row[c]).trim() !== '') {
      return row[c];
    }
  }

  const normRow = {};
  Object.keys(row).forEach(k => {
    normRow[normalizeFieldKey_(k)] = row[k];
  });

  for (let i = 0; i < candidates.length; i++) {
    const c = candidates[i];
    const v = normRow[normalizeFieldKey_(c)];
    if (v !== undefined && v !== null && String(v).trim() !== '') return v;
  }

  return '';
}

function cpos_guessQuestionId_(row) {
  if (!row || typeof row !== 'object') return '';
  const vals = Object.values(row || {});
  for (let i = 0; i < vals.length; i++) {
    const t = String(vals[i] || '').trim();
    if (/^Q_[A-Z0-9]+$/i.test(t)) return t;
  }
  return '';
}

function cpos_getSpreadsheet_() {
  const active = cpos_getSS_();
  if (active) return active;

  // Webapp/standalone fallback
  const id = PropertiesService.getScriptProperties().getProperty('CPOS_SPREADSHEET_ID');
  if (id) return SpreadsheetApp.openById(id);

  throw new Error('No active spreadsheet context. Set Script Property CPOS_SPREADSHEET_ID to your CPOS spreadsheet ID.');
}

function cpos_num_(v) {
  const n = Number(v);
  return isNaN(n) ? '' : n;
}

function cpos_boolLoose_(v) {
  if (v === true || v === false) return v;
  const s = String(v ?? '').trim().toLowerCase();
  if (s === 'true' || s === 'yes' || s === '1') return true;
  if (s === 'false' || s === 'no' || s === '0') return false;
  return '';
}

function cpos_canonLiteBoundsRow_(r) {
  return {
    Factor_ID: cpos_pickField_(r, ['Factor_ID', 'FactorID', 'Factor Id']),
    Factor_Category: cpos_pickField_(r, ['Factor_Category', 'FactorCategory', 'Factor Category']),
    Variable_Name: cpos_pickField_(r, ['Variable_Name', 'VariableName', 'Variable Name']),
    Factor_Display_Name: cpos_pickField_(r, ['Factor_Display_Name', 'FactorDisplayName', 'Factor Display Name']),
    Class_Order: cpos_num_(cpos_pickField_(r, ['Class_Order', 'ClassOrder', 'Class Order'])),
    Class_Label: cpos_pickField_(r, ['Class_Label', 'ClassLabel', 'Class Label']),
    Lower_Bound: cpos_num_(cpos_pickField_(r, ['Lower_Bound', 'LowerBound', 'Lower Bound'])),
    Upper_Bound: cpos_num_(cpos_pickField_(r, ['Upper_Bound', 'UpperBound', 'Upper Bound'])),
    Lower_Inclusive: cpos_boolLoose_(cpos_pickField_(r, ['Lower_Inclusive', 'LowerInclusive', 'Lower Inclusive'])),
    Upper_Inclusive: cpos_boolLoose_(cpos_pickField_(r, ['Upper_Inclusive', 'UpperInclusive', 'Upper Inclusive'])),
    Unit: cpos_pickField_(r, ['Unit', 'Units', 'Units_Label', 'UnitsLabel'])
  };
}

function cpos_canonLiteDesirRow_(r) {
  return {
    Variable_Name: cpos_pickField_(r, ['Variable_Name', 'VariableName', 'Variable Name']),
    Class_Label: cpos_pickField_(r, ['Class_Label', 'ClassLabel', 'Class Label']),
    Pathway: cpos_pickField_(r, ['Pathway', 'PathWay']),
    Desirability_0_1: cpos_num_(cpos_pickField_(r, ['Desirability_0_1', 'Desirability', 'Desirability (0-1)'])),
    Shape: cpos_pickField_(r, ['Shape']),
    Pathway_Context: cpos_pickField_(r, ['Pathway_Context', 'PathwayContext', 'Pathway Context'])
  };
}

function cpos_canonLiteWeightRow_(r) {
  return {
    Variable_Name: cpos_pickField_(r, ['Variable_Name', 'VariableName', 'Variable Name']),
    Pathway: cpos_pickField_(r, ['Pathway', 'PathWay']),
    Sensitivity_Weight_0_10: cpos_num_(cpos_pickField_(r, ['Sensitivity_Weight_0_10', 'SensitivityWeight_0_10', 'Sensitivity Weight (0-10)']))
  };
}

function srvr_getCPOSLiteTables() {
  return getCPOSLiteTables();
}

function srvr_getCPOSQuestionnaireConfig() {
    const res = getCPOSQuestionnaireConfig();
  if (res && typeof res === 'object') return res;
  return {
    ok: false,
    error: 'Questionnaire config returned empty response',
    bank: [],
    options: [],
    derivationRules: [],
    routingRules: [],
    signalToLiteMap: [],
    bounds: [],
    liteBounds: [],
    warnings: ['srvr_getCPOSQuestionnaireConfig fallback: empty response from getCPOSQuestionnaireConfig'],
    meta: null
  };
}



// =================================================================================================================================================================================================================
//                                                                                          LOGGERS / DEBUGGERS                                                                                                      **/
// =================================================================================================================================================================================================================

function TEST_LITE_getData() {
  const d = getCPOSData_Lite();
  Logger.log('ok=' + d.ok);
  Logger.log('vars=' + Object.keys(d.aspectsMap || {}).length);
  Logger.log('desir keys=' + Object.keys(d.desirIdx || {}).length);
  Logger.log('w keys=' + Object.keys(d.wIdx || {}).length);
}

function TEST_LITE_eval() {
  const selections = {
    'Crop Type': 'Rice (flooded)',
    'Water Management Intensity': 'AWD (intermittent drying)',
    'Drainage Class': 'Moderately / Imperfectly drained'
  };
  const r = evaluateCPOS_Lite_v1(selections, { debug: true });
  Logger.log(JSON.stringify(r, null, 2));
}

// Run this in Apps Script console
function testGetTables() {
  const result = getCPOSLiteTables();
  Logger.log('Bounds rows: ' + result.bounds.length);
  Logger.log('Desirability rows: ' + result.desirability.length);
  Logger.log('Weights rows: ' + result.weights.length);
  Logger.log('First bound: ' + JSON.stringify(result.bounds));
}


function debugQuestionColumns() {
  const ss = cpos_getSS_();
  const qBank = ss.getSheetByName('CPOS_Q_Bank');  // â† Corrected name

  if (!qBank) {
    Logger.log('âŒ CPOS_Q_Bank sheet not found!');
    return;
  }

  const headers = qBank.getRange(1, 1, 1, qBank.getLastColumn()).getValues()[0];

  Logger.log('=== CPOS_Q_Bank Column Headers ===');
  headers.forEach((h, i) => {
    Logger.log(`Column ${i + 1}: "${h}"`);
  });

  Logger.log('\n=== First Data Row (Q_S001) ===');
  const firstRow = qBank.getRange(2, 1, 1, headers.length).getValues()[0];
  headers.forEach((h, i) => {
    Logger.log(`${h}: ${firstRow[i]}`);
  });
}

function finalValidationTest() {
  Logger.log('=== FINAL VALIDATION TEST ===\n');

  // Test 1: CPOS Lite Tables
  const tables = getCPOSLiteTables();
  Logger.log('âœ… Bounds: ' + tables.bounds.length + ' rows');
  Logger.log('âœ… Desirability: ' + tables.desirability.length + ' rows');
  Logger.log('âœ… Weights: ' + tables.weights.length + ' rows\n');

  // Test 2: Questionnaire Config
  const config = getCPOSQuestionnaireConfig();
  Logger.log('âœ… Q_Bank: ' + config.bank.length + ' questions');
  Logger.log('âœ… Q_Options: ' + config.options.length + ' options');
  Logger.log('âœ… Derivation Rules: ' + config.derivationRules.length);
  Logger.log('âœ… Routing Rules: ' + config.routingRules.length);
  Logger.log('âœ… Signal Maps: ' + config.signalToLiteMap.length + '\n');

  // Test 3: Question Text Access
  if (config.bank.length > 0) {
    const q = config.bank[0];
    Logger.log('=== FIRST QUESTION CHECK ===');
    Logger.log('Question ID: ' + q.Question_ID);
    Logger.log('English: ' + (q.Question_Text_EN || 'âŒ MISSING'));
    Logger.log('Hindi: ' + (q.Question_Text_HI || 'âŒ MISSING'));
    Logger.log('Answer Type: ' + q.Answer_Type);
    Logger.log('Is Active: ' + q.Is_Active);
    Logger.log('Is Required: ' + q.Is_Required + '\n');
  }

  // Test 4: Sample Classification
  Logger.log('=== SAMPLE DATA CHECK ===');
  if (tables.bounds.length > 0) {
    const firstBound = tables.bounds[0];
    Logger.log('First variable: ' + firstBound.Variable_Name);
    Logger.log('Factor: ' + firstBound.Factor_Display_Name);
    Logger.log('Class: ' + firstBound.Class_Label);
    Logger.log('Range: ' + firstBound.Lower_Bound + ' - ' + firstBound.Upper_Bound);
    Logger.log('Unit: ' + firstBound.Unit);
  }

  Logger.log('\n=== VALIDATION COMPLETE ===');
  Logger.log('Status: READY FOR DEPLOYMENT ðŸš€');
}



function debugDerivationSheetColumns() {
  const ss = cpos_getSS_();
  const sheet = ss.getSheetByName('CPOS_Q_Derivation_Rules');

  if (!sheet) {
    Logger.log('âŒ Sheet "CPOS_Q_Derivation_Rules" not found!');
    Logger.log('Available sheets: ' + ss.getSheets().map(s => s.getName()).join(', '));
    return;
  }

  Logger.log('=== CPOS_Q_DERIVATION_RULES COLUMNS ===');
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];

  headers.forEach((h, i) => {
    Logger.log(`Column ${i + 1}: "${h}"`);
  });

  Logger.log('\n=== FIRST RULE (Row 2) ===');
  if (sheet.getLastRow() < 2) {
    Logger.log('âŒ No data rows! Sheet is empty.');
    return;
  }

  const firstRow = sheet.getRange(2, 1, 1, headers.length).getValues()[0];
  headers.forEach((h, i) => {
    const value = firstRow[i];
    const type = typeof value;
    Logger.log(`${h}: ${value} (${type})`);
  });

  Logger.log('\n=== ROW COUNT ===');
  Logger.log('Total rows with data: ' + (sheet.getLastRow() - 1));
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKEND DEBUG & TEST FUNCTIONS
// Add these to your Code.gs file for testing
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEST 1: Verify Derivation Rules Loaded
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function DEBUG_CheckDerivationRules() {
  const deriv = cpos_getTableFast_('CPOS_Q_Derivation_Rules');

  Logger.log('â•â•â• DERIVATION RULES CHECK â•â•â•');
  Logger.log('Total rules: ' + deriv.rows.length);

  // Check for new rules (R021-R041)
  const newRules = deriv.rows.filter(r => {
    const id = String(r.Rule_ID || '');
    const num = parseInt(id.replace('R', ''));
    return num >= 21 && num <= 41;
  });

  Logger.log('New rules (R021-R041): ' + newRules.length + ' (expect: 21)');

  if (newRules.length === 21) {
    Logger.log('âœ… All 21 new derivation rules loaded!');
  } else {
    Logger.log('âŒ MISSING RULES! Expected 21, found ' + newRules.length);
  }

  // Show sample rules
  Logger.log('\nâ•â•â• SAMPLE NEW RULES â•â•â•');
  const samples = [
    'R021', // MAIN_CROP - RICE_FLOODED
    'R030', // WATER_MANAGEMENT - CONTINUOUS_FLOOD
    'R035', // BIOCHAR_APPLICATION - YES
    'R038'  // ERW_ROCK_TYPE - BASALT
  ];

  samples.forEach(ruleId => {
    const rule = deriv.rows.find(r => String(r.Rule_ID) === ruleId);
    if (rule) {
      Logger.log(ruleId + ': ' + rule.When_Question_ID + ' = ' +
        rule.When_Value + ' â†’ ' + rule.Then_Signal_Key +
        ' = ' + rule.Then_Signal_Value);
    } else {
      Logger.log('âŒ ' + ruleId + ': NOT FOUND');
    }
  });

  return { total: deriv.rows.length, newRules: newRules.length };
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEST 2: Verify Routing Rules Loaded
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function DEBUG_CheckRoutingRules() {
  const routing = cpos_getTableFast_('CPOS_Q_Routing_Rules');

  Logger.log('â•â•â• ROUTING RULES CHECK â•â•â•');
  Logger.log('Total rules: ' + routing.rows.length);

  // Check for new rules (RT091-RT098)
  const newRules = routing.rows.filter(r => {
    const id = String(r.Route_ID || '');
    const num = parseInt(id.replace('RT', ''));
    return num >= 91 && num <= 98;
  });

  Logger.log('New rules (RT091-RT098): ' + newRules.length + ' (expect: 8)');

  if (newRules.length === 8) {
    Logger.log('âœ… All 8 new routing rules loaded!');
  } else {
    Logger.log('âŒ MISSING RULES! Expected 8, found ' + newRules.length);
  }

  // Show sample rules
  Logger.log('\nâ•â•â• SAMPLE NEW RULES â•â•â•');
  newRules.forEach(rule => {
    Logger.log(rule.Route_ID + ': ' + rule.Current_Question_ID +
      ' â†’ IF ' + rule.Condition_Signal_Key + ' = ' +
      rule.Condition_Value + ' â†’ ' + rule.Route_Action +
      ' ' + rule.Next_Question_ID);
  });

  return { total: routing.rows.length, newRules: newRules.length };
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEST 3: Test Backend Eligibility Logic (AWD - Rice Farmer)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function DEBUG_TestAWD_RiceFarmer() {
  Logger.log('â•â•â• TEST: AWD - Flooded Rice Farmer â•â•â•');

  const result = evaluateCPOS_Lite_v1(
    { 'Soil Organic Carbon (%)': '2.5' },
    {
      signals: {
        'MAIN_CROP': { value: 'RICE_FLOODED', confidence: 1.0 },
        'WATER_MANAGEMENT': { value: 'CONTINUOUS_FLOOD', confidence: 1.0 },
        'BIOCHAR_APPLICATION': { value: 'NO', confidence: 1.0 },
        'ERW_ROCK_TYPE': { value: 'NONE', confidence: 1.0 }
      },
      debug: true
    }
  );

  Logger.log('\nRESULTS:');
  Logger.log('RP-SOC: ' + result.results['RP-SOC'].eligibility);
  Logger.log('AWD-CHâ‚„: ' + result.results['AWD-CHâ‚„'].eligibility + ' (EXPECT: YES)');
  Logger.log('  Reason: ' + result.results['AWD-CHâ‚„'].reasons[0]);
  Logger.log('BIOCHAR: ' + result.results['BIOCHAR'].eligibility + ' (EXPECT: NO)');
  Logger.log('ERW: ' + result.results['ERW'].eligibility + ' (EXPECT: NO)');

  const pass = result.results['AWD-CHâ‚„'].eligibility === 'YES' &&
    result.results['BIOCHAR'].eligibility === 'NO' &&
    result.results['ERW'].eligibility === 'NO';

  Logger.log('\n' + (pass ? 'âœ… TEST PASSED' : 'âŒ TEST FAILED'));
  return result;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEST 4: Test Backend Eligibility Logic (AWD - Already Practicing)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function DEBUG_TestAWD_AlreadyPracticing() {
  Logger.log('â•â•â• TEST: AWD - Already Practicing (Not Eligible) â•â•â•');

  const result = evaluateCPOS_Lite_v1(
    { 'Soil Organic Carbon (%)': '2.5' },
    {
      signals: {
        'MAIN_CROP': { value: 'RICE_FLOODED', confidence: 1.0 },
        'WATER_MANAGEMENT': { value: 'AWD_MILD', confidence: 1.0 }
      },
      debug: true
    }
  );

  Logger.log('\nRESULTS:');
  Logger.log('AWD-CHâ‚„: ' + result.results['AWD-CHâ‚„'].eligibility + ' (EXPECT: NO)');
  Logger.log('  Reason: ' + result.results['AWD-CHâ‚„'].reasons[0]);

  const pass = result.results['AWD-CHâ‚„'].eligibility === 'NO';
  Logger.log('\n' + (pass ? 'âœ… TEST PASSED' : 'âŒ TEST FAILED'));
  return result;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEST 5: Test Backend Eligibility Logic (AWD - Wheat Farmer)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function DEBUG_TestAWD_WheatFarmer() {
  Logger.log('â•â•â• TEST: AWD - Wheat Farmer (Not Eligible) â•â•â•');

  const result = evaluateCPOS_Lite_v1(
    { 'Soil Organic Carbon (%)': '2.5' },
    {
      signals: {
        'MAIN_CROP': { value: 'WHEAT', confidence: 1.0 }
      },
      debug: true
    }
  );

  Logger.log('\nRESULTS:');
  Logger.log('AWD-CHâ‚„: ' + result.results['AWD-CHâ‚„'].eligibility + ' (EXPECT: NO)');
  Logger.log('  Reason: ' + result.results['AWD-CHâ‚„'].reasons[0]);

  const pass = result.results['AWD-CHâ‚„'].eligibility === 'NO';
  Logger.log('\n' + (pass ? 'âœ… TEST PASSED' : 'âŒ TEST FAILED'));
  return result;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEST 6: Test Backend Eligibility Logic (BIOCHAR User)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function DEBUG_TestBIOCHAR_User() {
  Logger.log('â•â•â• TEST: BIOCHAR - User Applying Biochar â•â•â•');

  const result = evaluateCPOS_Lite_v1(
    { 'Soil Organic Carbon (%)': '2.5' },
    {
      signals: {
        'BIOCHAR_APPLICATION': { value: 'YES', confidence: 1.0 },
        'ERW_ROCK_TYPE': { value: 'NONE', confidence: 1.0 }
      },
      debug: true
    }
  );

  Logger.log('\nRESULTS:');
  Logger.log('BIOCHAR: ' + result.results['BIOCHAR'].eligibility + ' (EXPECT: YES)');
  Logger.log('  Reason: ' + result.results['BIOCHAR'].reasons[0]);
  Logger.log('ERW: ' + result.results['ERW'].eligibility + ' (EXPECT: NO)');

  const pass = result.results['BIOCHAR'].eligibility === 'YES' &&
    result.results['ERW'].eligibility === 'NO';

  Logger.log('\n' + (pass ? 'âœ… TEST PASSED' : 'âŒ TEST FAILED'));
  return result;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEST 7: Test Backend Eligibility Logic (ERW User)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function DEBUG_TestERW_BasaltUser() {
  Logger.log('â•â•â• TEST: ERW - Basalt User â•â•â•');

  const result = evaluateCPOS_Lite_v1(
    { 'Soil Organic Carbon (%)': '2.5' },
    {
      signals: {
        'BIOCHAR_APPLICATION': { value: 'NO', confidence: 1.0 },
        'ERW_ROCK_TYPE': { value: 'BASALT', confidence: 1.0 }
      },
      debug: true
    }
  );

  Logger.log('\nRESULTS:');
  Logger.log('BIOCHAR: ' + result.results['BIOCHAR'].eligibility + ' (EXPECT: NO)');
  Logger.log('ERW: ' + result.results['ERW'].eligibility + ' (EXPECT: YES)');
  Logger.log('  Reason: ' + result.results['ERW'].reasons[0]);

  const pass = result.results['BIOCHAR'].eligibility === 'NO' &&
    result.results['ERW'].eligibility === 'YES';

  Logger.log('\n' + (pass ? 'âœ… TEST PASSED' : 'âŒ TEST FAILED'));
  return result;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RUN ALL BACKEND TESTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function DEBUG_RunAllBackendTests() {
  Logger.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  Logger.log('â•‘         RUNNING ALL BACKEND DEBUG TESTS                   â•‘');
  Logger.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  Logger.log('');

  const results = {
    derivationRules: false,
    routingRules: false,
    test1_RiceFarmer: false,
    test2_AlreadyAWD: false,
    test3_WheatFarmer: false,
    test4_BiocharUser: false,
    test5_ERWUser: false
  };

  try {
    // Test 1: Check derivation rules
    const deriv = DEBUG_CheckDerivationRules();
    results.derivationRules = (deriv.newRules === 21);
    Logger.log('');
  } catch (e) {
    Logger.log('âŒ Derivation rules check failed: ' + e);
  }

  try {
    // Test 2: Check routing rules
    const routing = DEBUG_CheckRoutingRules();
    results.routingRules = (routing.newRules === 8);
    Logger.log('');
  } catch (e) {
    Logger.log('âŒ Routing rules check failed: ' + e);
  }

  try {
    // Test 3: Rice farmer (AWD eligible)
    const t1 = DEBUG_TestAWD_RiceFarmer();
    results.test1_RiceFarmer = (t1.results['AWD-CHâ‚„'].eligibility === 'YES');
    Logger.log('');
  } catch (e) {
    Logger.log('âŒ Test 1 failed: ' + e);
  }

  try {
    // Test 4: Already practicing AWD
    const t2 = DEBUG_TestAWD_AlreadyPracticing();
    results.test2_AlreadyAWD = (t2.results['AWD-CHâ‚„'].eligibility === 'NO');
    Logger.log('');
  } catch (e) {
    Logger.log('âŒ Test 2 failed: ' + e);
  }

  try {
    // Test 5: Wheat farmer
    const t3 = DEBUG_TestAWD_WheatFarmer();
    results.test3_WheatFarmer = (t3.results['AWD-CHâ‚„'].eligibility === 'NO');
    Logger.log('');
  } catch (e) {
    Logger.log('âŒ Test 3 failed: ' + e);
  }

  try {
    // Test 6: Biochar user
    const t4 = DEBUG_TestBIOCHAR_User();
    results.test4_BiocharUser = (t4.results['BIOCHAR'].eligibility === 'YES');
    Logger.log('');
  } catch (e) {
    Logger.log('âŒ Test 4 failed: ' + e);
  }

  try {
    // Test 7: ERW user
    const t5 = DEBUG_TestERW_BasaltUser();
    results.test5_ERWUser = (t5.results['ERW'].eligibility === 'YES');
    Logger.log('');
  } catch (e) {
    Logger.log('âŒ Test 5 failed: ' + e);
  }

  // Summary
  Logger.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  Logger.log('â•‘                    TEST SUMMARY                            â•‘');
  Logger.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

  const passed = Object.values(results).filter(v => v === true).length;
  const total = Object.keys(results).length;

  Object.keys(results).forEach(key => {
    const status = results[key] ? 'âœ… PASS' : 'âŒ FAIL';
    Logger.log(status + ' - ' + key);
  });

  Logger.log('');
  Logger.log('TOTAL: ' + passed + '/' + total + ' tests passed');

  if (passed === total) {
    Logger.log('');
    Logger.log('ðŸŽ‰ ALL TESTS PASSED! Backend is ready!');
  } else {
    Logger.log('');
    Logger.log('âš ï¸  SOME TESTS FAILED. Check logs above for details.');
  }

  return results;
}

function DEBUG_TestQuestionnaireConfig() {
  Logger.log('=== TESTING getCPOSQuestionnaireConfig ===');

  try {
    const result = getCPOSQuestionnaireConfig();

    Logger.log('âœ… Function executed successfully');
    Logger.log('');
    Logger.log('Result keys: ' + Object.keys(result).join(', '));
    Logger.log('');
    Logger.log('ðŸ“Š COUNTS:');
    Logger.log('  bank.length: ' + (result.bank?.length || 0));
    Logger.log('  options.length: ' + (result.options?.length || 0));
    Logger.log('  derivationRules.length: ' + (result.derivationRules?.length || 0));
    Logger.log('  routingRules.length: ' + (result.routingRules?.length || 0));
    Logger.log('  signalToLiteMap.length: ' + (result.signalToLiteMap?.length || 0));
    Logger.log('');

    if (result.bank && result.bank.length > 0) {
      Logger.log('âœ… FIRST QUESTION:');
      Logger.log(JSON.stringify(result.bank[0], null, 2));
    } else {
      Logger.log('âŒ NO QUESTIONS FOUND!');
      Logger.log('');
      Logger.log('ðŸ”§ CHECK YOUR SHEET NAMES:');

      const ss = cpos_getSS_();
      const allSheets = ss.getSheets().map(s => s.getName());

      Logger.log('');
      Logger.log('ðŸ“‹ ALL SHEETS IN SPREADSHEET:');
      allSheets.forEach(name => Logger.log('  - ' + name));

      Logger.log('');
      Logger.log('âœ… REQUIRED SHEET NAMES:');
      Logger.log('  - CPOS_Q_Bank');
      Logger.log('  - CPOS_Q_Options');
      Logger.log('  - CPOS_Q_DerivationRules');
      Logger.log('  - CPOS_Q_RoutingRules');
      Logger.log('  - CPOS_Q_SignaltoLiteFactorMap');
    }

  } catch (error) {
    Logger.log('âŒ ERROR: ' + error.message);
    Logger.log('Stack: ' + error.stack);
  }
}

function DEBUG_CheckNormalizeExists() {
  Logger.log('=== CHECKING IF NORMALIZE FUNCTION EXISTS ===');

  try {
    // Try to call the function with dummy data
    const testData = [
      { Question_ID: 'TEST', Question_Text_EN: 'Test Question' }
    ];

    const result = normalizeQuestionnaireFields(testData);

    Logger.log('âœ… Function exists and executed!');
    Logger.log('');
    Logger.log('Input:');
    Logger.log(JSON.stringify(testData[0], null, 2));
    Logger.log('');
    Logger.log('Output:');
    Logger.log(JSON.stringify(result[0], null, 2));

    if (result[0].QuestionID) {
      Logger.log('');
      Logger.log('âœ… Normalization is working!');
      Logger.log('   Question_ID â†’ QuestionID âœ“');
    } else {
      Logger.log('');
      Logger.log('âŒ Normalization NOT working!');
      Logger.log('   Output still has: ' + Object.keys(result[0]).join(', '));
    }

  } catch (error) {
    Logger.log('âŒ ERROR: Function does not exist or has error!');
    Logger.log('   ' + error.message);
    Logger.log('');
    Logger.log('ðŸ”§ FIX: Add the normalizeQuestionnaireFields() function');
    Logger.log('   Make sure it is ABOVE getCPOSQuestionnaireConfig() in your Code.gs');
  }
}


function DEBUG_TestActualReturn() {
  Logger.log('=== TESTING ACTUAL RETURN VALUES ===');

  const result = getCPOSQuestionnaireConfig();

  if (!result.bank || result.bank.length === 0) {
    Logger.log('âŒ No questions returned!');
    return;
  }

  const firstQ = result.bank[0];

  Logger.log('ðŸ“‹ FIELD CHECK:');
  Logger.log('');
  Logger.log('Has QuestionID (normalized)?', !!firstQ.QuestionID);
  Logger.log('Has Question_ID (old)?', !!firstQ.Question_ID);
  Logger.log('');

  if (firstQ.QuestionID) {
    Logger.log('âœ… FIELDS ARE NORMALIZED!');
    Logger.log('   QuestionID: ' + firstQ.QuestionID);
    Logger.log('   QuestionTextEN: ' + firstQ.QuestionTextEN);
  } else if (firstQ.Question_ID) {
    Logger.log('âŒ FIELDS NOT NORMALIZED!');
    Logger.log('   Still has: Question_ID = ' + firstQ.Question_ID);
    Logger.log('');
    Logger.log('This means normalizeQuestionnaireFields() is NOT being called in getCPOSQuestionnaireConfig()');
  }

  Logger.log('');
  Logger.log('All keys in first question:');
  Object.keys(firstQ).forEach(k => Logger.log('  - ' + k));
}


function FINAL_TEST_DETAILED() {
  Logger.log('=== DETAILED FINAL TEST ===');
  Logger.log('');

  const result = getCPOSQuestionnaireConfig();

  Logger.log('Result structure:');
  Logger.log('  result.ok: ' + result.ok);
  Logger.log('  result.bank length: ' + (result.bank ? result.bank.length : 0));
  Logger.log('');

  if (!result.bank || result.bank.length === 0) {
    Logger.log('âŒ No questions in bank!');
    return;
  }

  const firstQ = result.bank[0];

  Logger.log('First question object:');
  Logger.log(JSON.stringify(firstQ, null, 2));
  Logger.log('');

  Logger.log('Field check:');
  Logger.log('  typeof firstQ.QuestionID: ' + typeof firstQ.QuestionID);
  Logger.log('  firstQ.QuestionID value: "' + firstQ.QuestionID + '"');
  Logger.log('  firstQ.QuestionID length: ' + (firstQ.QuestionID ? firstQ.QuestionID.length : 0));
  Logger.log('');
  Logger.log('  typeof firstQ.Question_ID: ' + typeof firstQ.Question_ID);
  Logger.log('  firstQ.Question_ID value: "' + (firstQ.Question_ID || 'undefined') + '"');
  Logger.log('');

  const hasNormalized = !!firstQ.QuestionID;
  const hasOld = !!firstQ.Question_ID;

  if (hasNormalized && !hasOld) {
    Logger.log('âœ…âœ…âœ… PERFECT! Normalization working! âœ…âœ…âœ…');
    Logger.log('');
    Logger.log('ðŸŽ¯ Next step: Reload your frontend');
    Logger.log('   Expected: Status pill shows QBank=' + result.bank.length);
  } else if (hasOld && !hasNormalized) {
    Logger.log('âŒ Normalization NOT working - still has snake_case');
  } else if (hasNormalized && hasOld) {
    Logger.log('âš ï¸  Both field names present (old and new)');
  } else {
    Logger.log('âŒ Neither field name present - data corrupted?');
  }
}

function QUICK_DEBUG() {
  Logger.log(JSON.stringify(debugSpreadsheetContext(), null, 2));
  Logger.log(JSON.stringify(debugTablePeek('CPOS_Lite_Bounds', 2), null, 2));
  Logger.log(JSON.stringify(debugTablePeek('CPOS_Q_Bank', 2), null, 2));
}
