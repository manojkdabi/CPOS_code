<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CP-OS v1.0 DSS (Lite)</title>

  <!-- ✅ DROP-IN (CLEAN) CSS: keeps your look, removes unrelated legacy overrides -->
  <style>
    :root {
      --bg: #f5f6fb;
      --surface: #ffffff;
      --surface2: #f2f3f7;
      --surface3: #e9edf5;

      --text: #1f2937;
      --muted: #5b6472;
      --muted2: #7a8494;

      --stroke: rgba(31, 41, 55, 0.14);
      --stroke2: rgba(31, 41, 55, 0.10);
      --divider: rgba(31, 41, 55, 0.08);

      --brandBlue1: #2f6fb5;
      --brandBlue2: #3c83c9;
      --brandField: #8fbf78;

      --primary: #2f6fb5;
      --primary2: #245ea6;

      --lemon: #f4d06f;
      --ok: #3a8f4b;
      --warn: #e6a83a;

      --recommended: #3c64b1;
      --conditional: #d77a1f;

      --shadow: 0 10px 24px rgba(28, 38, 63, 0.16);
      --shadow2: 0 16px 40px rgba(28, 38, 63, 0.18);

      --radius: 16px;
      --radius2: 22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue";
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      font-family: var(--sans);
      background: var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .app {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px 18px 28px
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 16px;
      padding: 12px 12px;
      border-radius: var(--radius2);
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.00)),
        linear-gradient(90deg, var(--brandBlue2), var(--brandField));
      color: #fff;
      box-shadow: var(--shadow2);
      border: 1px solid rgba(255, 255, 255, 0.20);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px
    }

    .logo {
      width: 44px;
      height: 44px;
      border-radius: 14px;
      background: linear-gradient(135deg, rgba(47, 111, 181, 0.95), rgba(143, 191, 120, 0.95));
      box-shadow: 0 12px 30px rgba(28, 38, 63, 0.22);
      position: relative;
    }

    .logo:after {
      content: "";
      position: absolute;
      inset: 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.35);
    }

    .titleblock .h1 {
      font-size: 18px;
      font-weight: 900;
      margin: 0
    }

    .status-pill {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.22);
      border: 1px solid rgba(255, 255, 255, 0.28);
      color: #fff;
      max-width: 520px;
    }

    .dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.65)
    }

    .dot.ok {
      background: var(--ok)
    }

    .dot.bad {
      background: #ef4444
    }

    .status-text {
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: rgba(255, 255, 255, 0.95);
    }

    .tabs {
      display: flex;
      gap: 10px;
      padding: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.70);
      border: 1px solid var(--stroke2);
      margin-bottom: 16px;
      overflow: auto;
      box-shadow: var(--shadow);
    }

    .tab {
      flex: 1;
      min-width: 260px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      cursor: pointer;
      border: 1px solid transparent;
      background: rgba(255, 255, 255, 0.85);
      color: var(--text);
      transition: all 120ms ease;
      user-select: none;
    }

    .tab:hover {
      background: rgba(255, 255, 255, 0.95)
    }

    .tab.active {
      background: linear-gradient(180deg, rgba(244, 208, 111, 0.60), rgba(255, 255, 255, 0.92));
      border-color: rgba(244, 208, 111, 0.90);
      box-shadow: 0 10px 22px rgba(28, 38, 63, 0.14);
    }

    .badgeNum {
      width: 28px;
      height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      font-weight: 950;
      font-size: 12px;
      background: rgba(31, 41, 55, 0.08);
      border: 1px solid rgba(31, 41, 55, 0.12);
    }

    .tab.active .badgeNum {
      background: rgba(244, 208, 111, 0.65);
      border-color: rgba(244, 208, 111, 0.95)
    }

    .tabText {
      display: flex;
      flex-direction: column;
      gap: 2px
    }

    .tab .label {
      font-weight: 900;
      font-size: 13px
    }

    .tab .desc {
      font-size: 12px;
      color: var(--muted)
    }

    .grid {
      display: grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap: 14px
    }

    @media (max-width:980px) {
      .grid {
        grid-template-columns: 1fr
      }
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--stroke);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .cardHeader {
      padding: 14px 16px;
      border-bottom: 1px solid var(--divider);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: linear-gradient(180deg, rgba(233, 237, 245, 0.75), rgba(255, 255, 255, 0));
    }

    .cardHeader .h2 {
      margin: 0;
      font-size: 13px;
      letter-spacing: 0.35px;
      font-weight: 950;
      text-transform: uppercase;
      color: var(--text);
    }

    .cardHeader .hint {
      font-size: 12px;
      color: var(--muted)
    }

    .cardBody {
      padding: 14px 16px 16px
    }

    .btnRow {
      display: flex;
      flex-wrap: wrap;
      gap: 10px
    }

    .btn {
      border-radius: 999px;
      padding: 10px 14px;
      border: 1px solid var(--stroke2);
      background: rgba(233, 237, 245, 0.85);
      color: var(--text);
      cursor: pointer;
      font-weight: 900;
      font-size: 13px;
      transition: all 120ms ease;
      user-select: none;
    }

    .btn:hover {
      background: rgba(233, 237, 245, 1)
    }

    .btn.primary {
      background: linear-gradient(180deg, rgba(47, 111, 181, 0.95), rgba(36, 94, 166, 0.95));
      border-color: rgba(36, 94, 166, 0.85);
      color: #fff;
    }

    .btn.ghost {
      background: rgba(255, 255, 255, 0.90)
    }

    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed
    }

    .formGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px
    }

    @media (max-width:980px) {
      .formGrid {
        grid-template-columns: 1fr
      }
    }

    .field {
      background: rgba(255, 255, 255, 0.92);
      border: 1px solid var(--stroke2);
      border-radius: 14px;
      padding: 10px 12px;
    }

    .field label {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .field label .cat {
      font-size: 11px;
      color: var(--muted2);
      border: 1px solid var(--stroke2);
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(233, 237, 245, 0.70);
      white-space: nowrap;
    }

    /* === Unit label pill (only the small % / mg/kg / etc chip) === */
    .field label .cat {
      background: rgb(220, 245, 225);
      /* light green fill */
      border-color: rgb(160, 215, 170);
      /* soft green border */
      color: rgb(35, 95, 55);
      /* dark green text */
      font-weight: 800;
    }


    input,
    textarea {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--stroke2);
      background: rgba(255, 255, 255, 0.95);
      color: var(--text);
      padding: 10px 10px;
      font-size: 13px;
      outline: none;
    }

    textarea {
      min-height: 84px;
      resize: vertical
    }

    .small {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.55
    }

    .mutedBox {
      border: 1px dashed rgba(47, 111, 181, 0.28);
      border-radius: 14px;
      padding: 12px 12px;
      background: linear-gradient(180deg, rgba(47, 111, 181, 0.10), rgba(255, 255, 255, 0.92));
      color: #111827;
      font-size: 13px;
      line-height: 1.6;
      white-space: pre-line;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 11px;
      border-radius: 999px;
      border: 1px solid var(--stroke2);
      background: rgba(255, 255, 255, 0.85);
      font-size: 13px;
      color: var(--text);
    }

    .chip .k {
      font-family: var(--mono);
      font-size: 11.5px;
      color: var(--muted2)
    }

    .pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 7px 11px;
      font-weight: 950;
      font-size: 12px;
      letter-spacing: 0.25px;
      border: 1px solid var(--stroke2);
      background: rgba(233, 237, 245, 0.85);
      text-transform: uppercase;
      color: var(--text);
    }

    .pill.ok {
      background: rgba(58, 143, 75, 0.18);
      border-color: rgba(58, 143, 75, 0.35);
      color: #1f5f2f
    }

    .pill.warn {
      background: rgba(215, 122, 31, 0.18);
      border-color: rgba(215, 122, 31, 0.35);
      color: #7a3f0a
    }

    .pill.bad {
      background: rgba(239, 68, 68, 0.10);
      border-color: rgba(239, 68, 68, 0.35);
      color: #991b1b
    }

    .pill.blue {
      background: rgba(60, 100, 177, 0.18);
      border-color: rgba(60, 100, 177, 0.35);
      color: #25408c
    }


    .pathGrid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px
    }

    @media (max-width:980px) {
      .pathGrid {
        grid-template-columns: 1fr
      }
    }

    .pathCard {
      position: relative;
      border: 1px solid rgba(31, 41, 55, 0.10);
      box-shadow: 0 10px 24px rgba(28, 38, 63, 0.10);
      overflow: hidden;
      border-radius: 18px;
      padding: 14px;
      background: linear-gradient(180deg, rgba(47, 111, 181, 0.07), rgba(255, 255, 255, 1) 60%);
    }

    .pathCard::before {
      content: "";
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      border-radius: 18px 0 0 18px;
      background: rgba(47, 111, 181, 0.55);
    }

    .pathCard.path-rp {
      background: linear-gradient(180deg, rgba(58, 143, 75, 0.10), rgba(255, 255, 255, 1) 60%)
    }

    .pathCard.path-rp::before {
      background: rgba(58, 143, 75, 0.60)
    }

    .pathCard.path-awd {
      background: linear-gradient(180deg, rgba(215, 122, 31, 0.10), rgba(255, 255, 255, 1) 60%)
    }

    .pathCard.path-awd::before {
      background: rgba(215, 122, 31, 0.60)
    }

    .pathCard.path-bio {
      background: linear-gradient(180deg, rgba(60, 100, 177, 0.10), rgba(255, 255, 255, 1) 60%)
    }

    .pathCard.path-bio::before {
      background: rgba(60, 100, 177, 0.60)
    }

    .pathCard.path-erw {
      background: linear-gradient(180deg, rgba(15, 118, 110, 0.10), rgba(255, 255, 255, 1) 60%)
    }

    .pathCard.path-erw::before {
      background: rgba(15, 118, 110, 0.60)
    }

    .pathTop {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 12px
    }

    .pathName {
      font-weight: 1000;
      font-size: 15px;
      margin: 0;
      color: var(--text)
    }

    .pathMeta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end
    }

    .list {
      margin: 8px 0 0;
      padding-left: 16px;
      color: rgba(31, 41, 55, 0.78);
      font-size: 13px;
      line-height: 1.6
    }

    .flag-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #cbd5e1;
      background: #f8fafc;
      color: #0f172a;
      font-size: 12px;
      line-height: 1;
      white-space: nowrap;
    }

    .flag-good {
      background: #DCFCE7;
      border-color: #86EFAC;
      color: #166534
    }

    .flag-bad {
      background: #FEE2E2;
      border-color: #FCA5A5;
      color: #991B1B
    }

    .flag-neutral {
      background: #F1F5F9;
      border-color: #CBD5E1;
      color: #334155
    }

    .panel {
      display: none
    }

    .panel.active {
      display: block
    }

    .foot {
      margin-top: 14px;
      font-size: 12px;
      color: rgba(31, 41, 55, 0.45);
      text-align: center
    }

    /* Data entry field title (e.g. Sand fraction) */
    .field>label>span:first-child {
      font-weight: 800;
      /* bold */
      color: rgb(128, 0, 32);
      /* maroon */
    }
  </style>
</head>

<body>
  <div class="app">
    <!-- Top Bar -->
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div class="titleblock">
          <div class="h1">Soil Carbon Pathway-Optimization System (SCP-OS) v1.0</div>
        </div>
      </div>
      <div class="status-pill">
        <div id="statusDot" class="dot"></div>
        <div id="statusText" class="status-text">Loading CPOS_Lite tables…</div>
      </div>
    </div>

    <!-- Tabs -->
    <div class="tabs" role="tablist" aria-label="CP-OS stages">
      <button class="tab active" role="tab" aria-selected="true" data-step="0" onclick="goStep(0)">
        <span class="badgeNum">0</span>
        <span class="tabText">
          <span class="label">Adaptive Questionnaire (Fast Setup)</span>
          <span class="desc">Auto-fill Step 1 inputs</span>
        </span>
      </button>

      <button class="tab" role="tab" aria-selected="false" data-step="1" onclick="goStep(1)">
        <span class="badgeNum">1</span>
        <span class="tabText">
          <span class="label">Land and Management context</span>
          <span class="desc">Enter values (auto-classify)</span>
        </span>
      </button>

      <button class="tab" role="tab" aria-selected="false" data-step="2" onclick="goStep(2)">
        <span class="badgeNum">2</span>
        <span class="tabText">
          <span class="label">Carbon Opportunity Analysis</span>
          <span class="desc">Scores • Eligibility • MRV tier</span>
        </span>
      </button>

      <button class="tab" role="tab" aria-selected="false" data-step="3" onclick="goStep(3)">
        <span class="badgeNum">3</span>
        <span class="tabText">
          <span class="label">Decision Summary</span>
          <span class="desc">Stack + Save</span>
        </span>
      </button>
    </div>

    <!-- PANELS -->
    <!-- ✅ ADD THIS ENTIRE LANGUAGE SELECTOR BLOCK -->
    <div
      style="margin-bottom:20px;padding:12px;background:rgba(255,255,255,0.95);border-radius:12px;border:1px solid var(--stroke2)">
      <label style="font-weight:600;margin-right:12px;font-size:14px">Language / भाषा:</label>
      <label style="margin-right:16px;cursor:pointer">
    <input type="radio" name="language" value="EN" id="langEN" checked> English
  </label>
      <label style="cursor:pointer">
    <input type="radio" name="language" value="HI" id="langHI"> हिन्दी (Hindi)
  </label>
    </div>
    <!-- ✅ END OF LANGUAGE SELECTOR -->


    <div id="panel0" class="panel active">
      <div class="grid">
        <!-- Left: questionnaire -->
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Adaptive Questionnaire</h3>
            <div class="hint">≈50 Q • Fast setup • Auto-fills Step 1</div>
          </div>
          <div class="cardBody">
            <div class="small" id="qProgress">Answered 0 / target 20</div>
            <div style="margin-top:10px" class="mutedBox" id="qQuestionText">Click Start to begin the questionnaire.
            </div>
            <div id="qHelpText" class="small" style="margin-top:8px"></div>
            <div id="qAnswerBox" style="margin-top:10px"></div>

            <div id="qNavStatus" class="small" style="margin-top:8px"></div>

            <div style="margin-top:12px" class="btnRow">
              <button class="btn ghost" id="btnQStart" onclick="qStart()">Start</button>
              <button class="btn ghost" id="btnQBack" onclick="qBack()" disabled>Back</button>
              <button class="btn ghost" id="btnQSkip" onclick="qSkip()" disabled>Skip</button>
              <button class="btn primary" id="btnQNext" onclick="qNext()" disabled>Next</button>
              <button class="btn primary" id="btnQFinish" onclick="qFinish()" disabled>Finish</button>
            </div>
          </div>
        </div>

        <!-- Right: derived signals + auto-fill -->
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Derived Signals + Auto-filled Factors</h3>
            <div class="hint">Questionnaire explainability</div>
          </div>
          <div class="cardBody">
            <div id="qDerivedBox" class="mutedBox">Signals and auto-filled factors will appear here.</div>
          </div>
        </div>
      </div>
    </div>

    <div id="panel1" class="panel">
      <div class="grid">
        <!-- Left -->
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Inputs</h3>
            <div class="hint">Grouped by Factor_Category • Numeric entry auto-classifies</div>
          </div>
          <div class="cardBody">
            <div class="formGrid" id="factorForm"></div>

            <div id="evalGate" style="margin-top:12px;">
              <div class="btnRow">
                <button class="btn ghost" onclick="clearSelections()">Clear</button>
                <button class="btn primary" id="btnEvaluate" onclick="evaluateAndGo()" disabled>Evaluate →</button>
              </div>
              <div id="evalGateHint" class="small" style="margin-top:8px"></div>
            </div>

            <div style="margin-top:10px" class="small" id="selectionHint">
              Tip: Enter any soil + climate + management values you have. You can evaluate even with partial inputs.
            </div>
          </div>
        </div>

        <!-- Right -->
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Explainability</h3>
            <div class="hint">Weights × desirability + Pathway_context</div>
          </div>
          <div class="cardBody">
            <div id="notesBox" class="mutedBox">
              Enter values to view class, desirability, and pathway context here.
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="panel2" class="panel">
      <div class="grid">
        <!-- Left: results -->
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Pathway Screening</h3>
            <div class="hint">Computed from CPOS_Lite_Bounds + CPOS_Lite_Desirability + CPOS_Lite_Weights</div>
          </div>
          <div class="cardBody">
            <div id="screeningGrid" class="pathGrid"></div>

            <div style="margin-top:12px" class="btnRow">
              <button class="btn ghost" onclick="goStep(1)">← Back</button>
              <button class="btn primary" onclick="goStep(3)">Decision Summary →</button>
            </div>
          </div>
        </div>

        <!-- Right: selection recap -->
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Current Inputs</h3>
            <div class="hint">Observed_Value + classified Class_Label</div>
          </div>
          <div class="cardBody">
            <div id="selectionRecap" class="chips"></div>
            <div style="margin-top:12px" class="mutedBox" id="mrvStrip">
              MRV focus strip will appear after evaluation.
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="panel3" class="panel">
      <div class="grid">
        <!-- Left: decision summary -->
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Decision Summary</h3>
            <div class="hint">Recommended stack + key cautions</div>
          </div>
          <div class="cardBody">
            <div id="headlineBox" class="mutedBox">Evaluate at least one input to generate a decision summary.</div>

            <div class="small" style="margin-bottom:8px;color:var(--muted)"><b>Recommended</b></div>
            <div id="recStack" class="chips" style="margin-bottom:12px"></div>

            <div class="small" style="margin-bottom:8px;color:var(--muted)"><b>Conditional</b></div>
            <div id="condStack" class="chips" style="margin-bottom:12px"></div>

            <div class="small" style="margin-bottom:8px;color:var(--muted)"><b>Excluded</b></div>
            <div id="exclStack" class="chips" style="margin-bottom:8px"></div>

            <div style="margin-top:12px" class="btnRow">
              <button class="btn ghost" onclick="goStep(2)">← Back</button>
              <button class="btn primary" onclick="openSaveDrawer()">Save Assessment</button>
            </div>
          </div>
        </div>

        <!-- Right: save drawer -->
        <div class="card">
          <div class="cardHeader">
            <h3 class="h2">Save Assessment</h3>
            <div class="hint">Optional (Apps Script)</div>
          </div>
          <div class="cardBody">
            <div class="small" style="margin-bottom:10px">
              Optional in v1.0. If your assessment sheet + backend function is ready, fill fields and save.
            </div>

            <div class="formGrid">
              <div class="field">
                <label>Client_ID <span class="cat">meta</span></label>
                <input id="metaClientId" placeholder="Default">
              </div>
              <div class="field">
                <label>Site_ID <span class="cat">meta</span></label>
                <input id="metaSiteId" placeholder="SITE-001">
              </div>
              <div class="field">
                <label>Site_Name <span class="cat">meta</span></label>
                <input id="metaSiteName" placeholder="Village / Farm / Plot">
              </div>
              <div class="field">
                <label>Crop_System <span class="cat">meta</span></label>
                <input id="metaCropSystem" placeholder="Rice paddy / Upland cereal / etc.">
              </div>
              <div class="field">
                <label>Latitude <span class="cat">meta</span></label>
                <input id="metaLat" placeholder="26.1234">
              </div>
              <div class="field">
                <label>Longitude <span class="cat">meta</span></label>
                <input id="metaLon" placeholder="81.9876">
              </div>
              <div class="field">
                <label>State <span class="cat">meta</span></label>
                <input id="metaState" placeholder="UP">
              </div>
              <div class="field">
                <label>District <span class="cat">meta</span></label>
                <input id="metaDistrict" placeholder="Sonbhadra">
              </div>
              <div class="field" style="grid-column:1/-1">
                <label>Notes <span class="cat">meta</span></label>
                <textarea id="metaNotes" placeholder="Any assumptions, site notes, constraints…"></textarea>
              </div>
            </div>

            <div style="margin-top:12px" class="btnRow">
              <button class="btn ghost" onclick="fillDemoMeta()">Fill Demo</button>
              <button class="btn primary" onclick="saveAssessment()">Save → Sheet</button>
            </div>

            <div id="saveStatus" style="margin-top:10px" class="small"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="foot">CP-OS v1.0 • CPOS-Lite (Bounds + Desirability + Weights)</div>
  </div>

  <script>
    // ============================================================
    // ✅ CPOS-LITE FRONTEND (DROP-IN) + QUESTIONNAIRE ENGINE
    // ============================================================

    function setStatus(ok, msg) {
      const dot = document.getElementById('statusDot');
      const text = document.getElementById('statusText');
      dot.classList.remove('ok','bad');
      dot.classList.add(ok ? 'ok' : 'bad');
      text.textContent = msg || (ok ? 'Ready' : 'Error');
    }

    function goStep(n) {
      document.querySelectorAll('.tab').forEach(el => {
        const isActive = Number(el.dataset.step) === Number(n);
        el.classList.toggle('active', isActive);
        el.setAttribute('aria-selected', isActive ? 'true' : 'false');
      });
      document.getElementById('panel0').classList.toggle('active', n === 0);
      document.getElementById('panel1').classList.toggle('active', n === 1);
      document.getElementById('panel2').classList.toggle('active', n === 2);
      document.getElementById('panel3').classList.toggle('active', n === 3);
    }

    function escapeHtml(s){
      return String(s ?? '')
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'","&#039;");
    }

    function makePill(type, text) {
      const span = document.createElement('span');
      span.className = 'pill ' + (type || '');
      span.textContent = text;
      return span;
    }

    function makeChip(label, value) {
      const div = document.createElement('div');
      div.className = 'chip';
      div.innerHTML = `<span class="k">${escapeHtml(label)}</span> <span>${escapeHtml(value)}</span>`;
      return div;
    }

    function toNum(v){
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }
    function toBool(v){
      if (typeof v === 'boolean') return v;
      const s = String(v || '').trim().toLowerCase();
      return (s === 'true' || s === '1' || s === 'yes' || s === 'y');
    }

    function normKey_(s) {
      return String(s ?? '')
        .normalize('NFKC')
        .trim()
        .replace(/\u00A0/g, ' ')
        .replace(/[–—]/g, '-')
        .replace(/\s+/g, ' ');
    }

    function normPathway_(p) {
      const s = normKey_(p);
      const k = s.toLowerCase();
      if (k === 'rp-soc' || k === 'rp soc' || k === 'regenerative ag' || k === 'regenerative agriculture') return 'RP-SOC';
      if (k === 'awd' || k === 'awd-ch4' || k === 'awd-ch₄' || k === 'awd ch4') return 'AWD-CH₄';
      if (k === 'biochar') return 'BIOCHAR';
      if (k === 'erw') return 'ERW';
      return s;
    }

    function safeCall_(label, fn) {
      try {
        fn();
      } catch (err) {
        console.error(`[CPOS] ${label} failed`, err);
        setStatus(false, `${label} error: ${err?.message || err}`);
      }
    }

    // ---------------------------
    // CPOS-Lite state + indexes
    // ---------------------------
    const CPOSL = {
      language: 'EN', // Default language: 'EN' or 'HI'

      PATHWAYS: ['RP-SOC', 'AWD-CH₄', 'BIOCHAR', 'ERW'],
      data: { bounds:[], desirability:[], weights:[] },
      idx: {
        boundsByVar: new Map(),
        factorsByCat: new Map(),
        desirByVarPathClass: new Map(),
        weightByVarPath: new Map()
      },
      selections: {},
      computed: {},
      lastResults: null,
      q: {
        bank: [],
        options: [],
        derivationRules: [],
        routingRules: [],
        signalToLiteMap: [],
        liteBounds: [],
        idx: {
          qBankById: new Map(),
          qOptionsByQ: new Map(),
          qDerivByWhenQ: new Map(),
          qRoutesByCurrentQ: new Map(),
          qSignalMapByKey: new Map(),
          startQuestions: []
        }
      },
      qState: {
        mode: 'BASIC',
        sessionId: '',
        answered: {},
        signals: {},
        queue: [],
        current: null,
        history: [],
        answeredCount: 0,
        minTarget: 20,
        maxCap: 50,
        stop: false
      }

    };

    // ---------------------------
    // Backend loader (single call)
    // ---------------------------
    function getCPOSLiteTables() {
      return new Promise((resolve, reject) => {
        if (typeof google === 'undefined' || !google.script || !google.script.run) {
          reject(new Error('Apps Script runtime not available (local mode).'));
          return;
        }
        google.script.run
          .withSuccessHandler(res => resolve(res || {}))
          .withFailureHandler(err => reject(err))
          .getCPOSLiteTables();
      });
    }

    function getCPOSQuestionnaireConfig() {
      return new Promise((resolve, reject) => {
        if (typeof google === 'undefined' || !google.script || !google.script.run) {
          reject(new Error('Apps Script runtime not available (local mode).'));
          return;
        }
        google.script.run
          .withSuccessHandler(res => resolve(res || {}))
          .withFailureHandler(err => reject(err))
          .getCPOSQuestionnaireConfig();
      });
    }

    // ---------------------------
    // Build indexes from 3 sheets
    // ---------------------------
    function buildIndexes_() {
      CPOSL.idx.boundsByVar = new Map();
      CPOSL.idx.factorsByCat = new Map();
      CPOSL.idx.desirByVarPathClass = new Map();
      CPOSL.idx.weightByVarPath = new Map();

      for (const r of (CPOSL.data.bounds || [])) {
        const varNameRaw = String(r.Variable_Name || '').trim();
        const varKey = normKey_(varNameRaw);
        if (!varKey) continue;

        const factorCategoryRaw = String(r.Factor_Category || 'Other').trim();
        const factorCategoryKey = normKey_(factorCategoryRaw);
        const factorDisplay = String(r.Factor_Display_Name || varNameRaw).trim();

        const f = CPOSL.idx.boundsByVar.get(varKey) || {
          Variable_Name: varKey,
          Variable_Name_Display: varNameRaw || varKey,
          Factor_ID: normKey_(r.Factor_ID || ''),
          Factor_Category: factorCategoryKey,
          Factor_Category_Display: factorCategoryRaw || factorCategoryKey,
          Factor_Display_Name: factorDisplay || varKey,
          Unit: String(r.Unit || '').trim(),
          classes: []
        };

        const classLabelRaw = String(r.Class_Label || '').trim();
        const classKey = normKey_(classLabelRaw);
        if (!classKey) continue;

        f.classes.push({
          Class_Order: toNum(r.Class_Order),
          Class_Label: classKey,
          Class_Label_Display: classLabelRaw || classKey,
          Lower_Bound: toNum(r.Lower_Bound),
          Upper_Bound: toNum(r.Upper_Bound),
          Lower_Inclusive: toBool(r.Lower_Inclusive),
          Upper_Inclusive: toBool(r.Upper_Inclusive)
        });

        CPOSL.idx.boundsByVar.set(varKey, f);
      }

      for (const [, f] of CPOSL.idx.boundsByVar.entries()) {
        f.classes.sort((a, b) => (a.Class_Order ?? 0) - (b.Class_Order ?? 0));

        const catKey = f.Factor_Category || 'Other';
        if (!CPOSL.idx.factorsByCat.has(catKey)) {
          CPOSL.idx.factorsByCat.set(catKey, { label: f.Factor_Category_Display || catKey, factors: [] });
        }
        CPOSL.idx.factorsByCat.get(catKey).factors.push(f);
      }

      for (const entry of CPOSL.idx.factorsByCat.values()) {
        entry.factors.sort((a, b) => (a.Factor_Display_Name || '').localeCompare(b.Factor_Display_Name || ''));
      }

      for (const r of (CPOSL.data.desirability || [])) {
        const varKey = normKey_(r.Variable_Name);
        const pathway = normPathway_(r.Pathway);
        const classKey = normKey_(r.Class_Label);
        if (!varKey || !pathway || !classKey) continue;

        const d = toNum(r.Desirability_0_1);
        if (!Number.isFinite(d)) continue;

        const key = `${varKey}||${pathway}||${classKey}`;
        CPOSL.idx.desirByVarPathClass.set(key, {
          d,
          shape: String(r.Shape || '').trim(),
          ctx: String(r.Pathway_Context || '').trim()
        });
      }

      for (const r of (CPOSL.data.weights || [])) {
        const varKey = normKey_(r.Variable_Name);
        const pathway = normPathway_(r.Pathway);
        if (!varKey || !pathway) continue;

        const w = toNum(r.Sensitivity_Weight_0_10);
        if (!Number.isFinite(w)) continue;

        const key = `${varKey}||${pathway}`;
        CPOSL.idx.weightByVarPath.set(key, w);
      }

      console.log('[CPOS] buildIndexes', {
        boundsVars: CPOSL.idx.boundsByVar.size,
        desirKeys: CPOSL.idx.desirByVarPathClass.size,
        weightKeys: CPOSL.idx.weightByVarPath.size
      });
    }

    // ---------------------------
    // Questionnaire indexes
    // ---------------------------
    function buildQuestionnaireIndexes_() {
      const idx = CPOSL.q.idx;
      idx.qBankById = new Map();
      idx.qOptionsByQ = new Map();
      idx.qDerivByWhenQ = new Map();
      idx.qRoutesByCurrentQ = new Map();
      idx.qSignalMapByKey = new Map();
      idx.startQuestions = [];

      const bank = Array.isArray(CPOSL.q.bank) ? CPOSL.q.bank : [];
      const options = Array.isArray(CPOSL.q.options) ? CPOSL.q.options : [];
      const derivs = Array.isArray(CPOSL.q.derivationRules) ? CPOSL.q.derivationRules : [];
      const routes = Array.isArray(CPOSL.q.routingRules) ? CPOSL.q.routingRules : [];
      const maps = Array.isArray(CPOSL.q.signalToLiteMap) ? CPOSL.q.signalToLiteMap : [];

      bank.forEach(r => {
        const id = String(r.Question_ID || '').trim();
        if (!id) return;
        idx.qBankById.set(id, r);
      });

      options.forEach(r => {
        const qid = String(r.Question_ID || '').trim();
        if (!qid) return;
        if (!idx.qOptionsByQ.has(qid)) idx.qOptionsByQ.set(qid, []);
        idx.qOptionsByQ.get(qid).push(r);
      });

      for (const arr of idx.qOptionsByQ.values()) {
        arr.sort((a, b) => (toNum(a.Option_Order) ?? 9999) - (toNum(b.Option_Order) ?? 9999));
      }

      derivs.forEach(r => {
        const qid = String(r.When_Question_ID || '').trim();
        if (!qid) return;
        if (!idx.qDerivByWhenQ.has(qid)) idx.qDerivByWhenQ.set(qid, []);
        idx.qDerivByWhenQ.get(qid).push(r);
      });

      for (const arr of idx.qDerivByWhenQ.values()) {
        arr.sort((a, b) => (toNum(a.Priority) ?? 9999) - (toNum(b.Priority) ?? 9999));
      }

      routes.forEach(r => {
        const qid = String(r.Current_Question_ID || '').trim();
        if (!qid) return;
        if (!idx.qRoutesByCurrentQ.has(qid)) idx.qRoutesByCurrentQ.set(qid, []);
        idx.qRoutesByCurrentQ.get(qid).push(r);
      });

      for (const arr of idx.qRoutesByCurrentQ.values()) {
        arr.sort((a, b) => (toNum(a.Priority) ?? 9999) - (toNum(b.Priority) ?? 9999));
      }

      maps.forEach(r => {
        if (!toBool(r.Is_Active)) return;
        const key = String(r.Signal_Key || '').trim();
        if (!key) return;
        if (!idx.qSignalMapByKey.has(key)) idx.qSignalMapByKey.set(key, []);
        idx.qSignalMapByKey.get(key).push(r);
      });

      const activeBank = bank.filter(r => toBool(r.Is_Active));
      const modeBank = activeBank.filter(r => {
        const mode = String(r.Mode || '').trim();
        return !mode || mode.toUpperCase() === CPOSL.qState.mode.toUpperCase();
      });

      const startByGroup = modeBank.filter(r => String(r.Group_Code || '').trim().toUpperCase() === 'START');
      if (startByGroup.length) {
        idx.startQuestions = startByGroup.map(r => String(r.Question_ID || '').trim()).filter(Boolean);
      } else {
        const sequences = modeBank.map(r => toNum(r.Sequence)).filter(v => v !== null);
        const minSeq = sequences.length ? Math.min.apply(null, sequences) : null;
        if (minSeq !== null) {
          idx.startQuestions = modeBank.filter(r => toNum(r.Sequence) === minSeq).map(r => String(r.Question_ID || '').trim()).filter(Boolean);
        } else if (modeBank.length) {
          const sorted = modeBank.slice().sort((a, b) => (toNum(a.Sequence) ?? 9999) - (toNum(b.Sequence) ?? 9999));
          idx.startQuestions = [String(sorted[0].Question_ID || '').trim()].filter(Boolean);
        }
      }

      console.log('[CPOS][Q] indexes built', {
        bank: idx.qBankById.size,
        options: idx.qOptionsByQ.size,
        deriv: idx.qDerivByWhenQ.size,
        routes: idx.qRoutesByCurrentQ.size,
        signalMaps: idx.qSignalMapByKey.size,
        starts: idx.startQuestions.length
      });
    }

    // ---------------------------
// ✅ NEW: Sequential question finder
// ---------------------------
function findNextSequentialQuestion_(currentQid) {
  const currentQ = CPOSL.q.idx.qBankById.get(currentQid);
  if (!currentQ) return null;

  const currentSeq = toNum(currentQ.Sequence);
  if (currentSeq === null) return null;

  const activeQuestions = Array.from(CPOSL.q.idx.qBankById.values()).filter(q => {
    if (!toBool(q.Is_Active)) return false;
    const qMode = String(q.Mode || '').trim().toUpperCase();
    const currentMode = CPOSL.qState.mode.toUpperCase();
    return !qMode || qMode === currentMode;
  });

  activeQuestions.sort((a, b) => (toNum(a.Sequence) ?? 9999) - (toNum(b.Sequence) ?? 9999));

  // Find next REQUIRED question with higher sequence
  for (const q of activeQuestions) {
    const qSeq = toNum(q.Sequence);
    const qid = String(q.Question_ID || '').trim();
    const isRequired = toBool(q.Is_Required);
    
    if (qSeq > currentSeq && !CPOSL.qState.answered[qid] && qid !== currentQid) {
      // Only auto-add if Is_Required=TRUE
      // Conditional questions (Is_Required=FALSE) must be added by routing rules
      if (isRequired) {
        return qid;
      }
    }
  }

  return null;
}

    // ---------------------------
    // QUESTIONNAIRE ENGINE
    // ---------------------------
function renderQuestionUI_() {
  const qid = CPOSL.qState.current;
  if (!qid) {
    document.getElementById('qQuestionText').textContent = 'No current question.';
    document.getElementById('qHelpText').textContent = '';
    document.getElementById('qAnswerBox').innerHTML = '';
    return;
  }

  const qRow = CPOSL.q.idx.qBankById.get(qid);
  if (!qRow) {
    document.getElementById('qQuestionText').textContent = `Question ${qid} not found.`;
    document.getElementById('qHelpText').textContent = '';
    document.getElementById('qAnswerBox').innerHTML = '';
    return;
  }

  // ✅ NEW: Get text based on selected language
  const lang = CPOSL.language || 'EN';
  const questionText = lang === 'HI' && qRow.Question_Text_HI 
    ? String(qRow.Question_Text_HI).trim() 
    : String(qRow.Question_Text || qid).trim();
  const helpText = lang === 'HI' && qRow.Help_Text_HI 
    ? String(qRow.Help_Text_HI).trim() 
    : String(qRow.Help_Text || '').trim();
  
  const qType = String(qRow.Answer_Type || '').trim().toLowerCase();
  const opts = CPOSL.q.idx.qOptionsByQ.get(qid) || [];

  document.getElementById('qQuestionText').textContent = questionText;
  document.getElementById('qHelpText').textContent = helpText;

  const answerBox = document.getElementById('qAnswerBox');
  answerBox.innerHTML = '';

  const prevAnswer = CPOSL.qState.answered[qid];
  const prevRaw = prevAnswer ? prevAnswer.Answer_Raw : '';

  let actualType = qType;
  
  if (!actualType) {
    actualType = opts.length ? 'single_select' : 'text';
  }

  if (actualType === 'single_select' && opts.length === 0) {
    console.warn(`[Q] ${qid} is single_select but has no options. Falling back to text input.`);
    actualType = 'text';
  }
  
  if (actualType === 'multi_select' && opts.length === 0) {
    console.warn(`[Q] ${qid} is multi_select but has no options. Falling back to textarea.`);
    actualType = 'text_multi';
  }

 if (actualType === 'single_select') {
  opts.forEach(opt => {
    const code = String(opt.Option_Code || '').trim();
    const label = lang === 'HI' && opt.Option_Label_HI 
      ? String(opt.Option_Label_HI).trim() 
      : String(opt.Option_Label || code).trim();
    const checked = (prevRaw === code) ? 'checked' : '';
    const radioId = `q_${qid}_${code}`.replace(/[^a-zA-Z0-9_]/g, '_');
    const div = document.createElement('div');
    div.style.cssText = 'display:grid;grid-template-columns:30px 1fr;gap:20px;align-items:center;margin-bottom:10px';
    div.innerHTML = `
      <input type="radio" name="q_${qid}" value="${escapeHtml(code)}" id="${radioId}" ${checked} style="margin:0;cursor:pointer">
      <label for="${radioId}" style="margin:0;cursor:pointer;text-align:left;line-height:1.5">${escapeHtml(label)}</label>
    `;


      answerBox.appendChild(div);
      
      const radio = div.querySelector('input');
      radio.addEventListener('change', () => {
        updateQuestionnaireUIState_();
      });
    });
  } 
else if (actualType === 'multi_select') {
  opts.forEach(opt => {
    const code = String(opt.Option_Code || '').trim();
    const label = lang === 'HI' && opt.Option_Label_HI 
      ? String(opt.Option_Label_HI).trim() 
      : String(opt.Option_Label || code).trim();
    const prevCodes = prevRaw ? prevRaw.split(',').map(x => x.trim()) : [];
    const checked = prevCodes.includes(code) ? 'checked' : '';
    const cbId = `q_${qid}_${code}`.replace(/[^a-zA-Z0-9_]/g, '_');
    const div = document.createElement('div');
    div.style.cssText = 'display:grid;grid-template-columns:30px 1fr;gap:20px;align-items:center;margin-bottom:10px';
    div.innerHTML = `
      <input type="checkbox" name="q_${qid}" value="${escapeHtml(code)}" id="${cbId}" ${checked} style="margin:0;cursor:pointer">
      <label for="${cbId}" style="margin:0;cursor:pointer;text-align:left;line-height:1.5">${escapeHtml(label)}</label>
    `;


      answerBox.appendChild(div);
      
      const cb = div.querySelector('input');
      cb.addEventListener('change', () => {
        updateQuestionnaireUIState_();
      });
    });
  } 
  else if (actualType === 'number' || actualType === 'rating_1_5') {
    const inp = document.createElement('input');
    inp.type = 'number';
    inp.id = `q_${qid}_num`;
    // ✅ NEW: Localized placeholder
    const placeholder = lang === 'HI' 
      ? (actualType === 'rating_1_5' ? '1-5 दर्ज करें' : 'संख्यात्मक मान दर्ज करें')
      : (actualType === 'rating_1_5' ? 'Enter 1-5' : 'Enter numeric value');
    inp.placeholder = placeholder;
    if (actualType === 'rating_1_5') {
      inp.min = '1';
      inp.max = '5';
      inp.step = '1';
    }
    inp.value = prevRaw;
    inp.style.cssText = 'width:100%;border-radius:12px;border:1px solid var(--stroke2);background:rgba(255,255,255,0.95);color:var(--text);padding:10px;font-size:13px';
    answerBox.appendChild(inp);
    
    inp.addEventListener('input', () => {
      updateQuestionnaireUIState_();
    });
  } 
  else if (actualType === 'text_multi') {
    const inp = document.createElement('textarea');
    inp.id = `q_${qid}_text`;
    // ✅ NEW: Localized placeholder
    const placeholder = lang === 'HI' 
      ? 'अपना उत्तर दर्ज करें (कॉमा से अलग करें)'
      : 'Enter your answer (multiple items separated by commas)';
    inp.placeholder = placeholder;
    inp.value = prevRaw;
    inp.style.cssText = 'width:100%;border-radius:12px;border:1px solid var(--stroke2);background:rgba(255,255,255,0.95);color:var(--text);padding:10px;font-size:13px;min-height:80px;resize:vertical';
    answerBox.appendChild(inp);
    
    inp.addEventListener('input', () => {
      updateQuestionnaireUIState_();
    });
  } 
  else {
    const inp = document.createElement('input');
    inp.type = 'text';
    inp.id = `q_${qid}_text`;
    // ✅ NEW: Localized placeholder
    const placeholder = lang === 'HI' ? 'अपना उत्तर दर्ज करें' : 'Enter your answer';
    inp.placeholder = placeholder;
    inp.value = prevRaw;
    inp.style.cssText = 'width:100%;border-radius:12px;border:1px solid var(--stroke2);background:rgba(255,255,255,0.95);color:var(--text);padding:10px;font-size:13px';
    answerBox.appendChild(inp);
    
    inp.addEventListener('input', () => {
      updateQuestionnaireUIState_();
    });
  }
}





function readAnswerFromUI_() {
  const qid = CPOSL.qState.current;
  if (!qid) return null;

  const qRow = CPOSL.q.idx.qBankById.get(qid);
  if (!qRow) return null;

  const qType = String(qRow.Answer_Type || '').trim().toLowerCase();
  const opts = CPOSL.q.idx.qOptionsByQ.get(qid) || [];
  
  let actualType = qType;
  if (!actualType) {
    actualType = opts.length ? 'single_select' : 'text';
  }

  // ✅ Handle fallback cases
  if (actualType === 'single_select' && opts.length === 0) {
    actualType = 'text';
  }
  if (actualType === 'multi_select' && opts.length === 0) {
    actualType = 'text_multi';
  }

  // ✅ SINGLE SELECT (radio)
  if (actualType === 'single_select') {
    const radio = document.querySelector(`input[name="q_${qid}"]:checked`);
    return radio ? radio.value : null;
  } 
  // ✅ MULTI SELECT (checkboxes)
  else if (actualType === 'multi_select') {
    const boxes = document.querySelectorAll(`input[name="q_${qid}"]:checked`);
    const codes = Array.from(boxes).map(b => b.value);
    return codes.length ? codes.join(',') : null;
  } 
  // ✅ NUMBER or RATING
  else if (actualType === 'number' || actualType === 'rating_1_5') {
    const inp = document.getElementById(`q_${qid}_num`);
    return inp ? inp.value.trim() : null;
  } 
  // ✅ TEXTAREA (multi-line fallback)
  else if (actualType === 'text_multi') {
    const inp = document.getElementById(`q_${qid}_text`);
    return inp ? inp.value.trim() : null;
  } 
  // ✅ TEXT INPUT (default)
  else {
    const inp = document.getElementById(`q_${qid}_text`);
    return inp ? inp.value.trim() : null;
  }
}




// ---------------------------
// Intelligent crop/season parser (Enhanced)
// ---------------------------
function parseCropAnswer_(rawText) {
  if (!rawText || typeof rawText !== 'string') return null;
  
  const text = rawText.toLowerCase().trim();
  if (!text) return null;

  const cropMap = {
    'rice': 'RICE', 'paddy': 'RICE', 'dhan': 'RICE',
    'wheat': 'WHEAT', 'gehu': 'WHEAT', 'gehun': 'WHEAT',
    'maize': 'MAIZE', 'corn': 'MAIZE', 'makka': 'MAIZE',
    'sugarcane': 'SUGARCANE', 'ganna': 'SUGARCANE', 'cane': 'SUGARCANE',
    'cotton': 'COTTON', 'kapas': 'COTTON',
    'soybean': 'SOYBEAN', 'soya': 'SOYBEAN',
    'chickpea': 'CHICKPEA', 'chana': 'CHICKPEA', 'gram': 'CHICKPEA',
    'pigeon pea': 'PIGEON_PEA', 'tur': 'PIGEON_PEA', 'arhar': 'PIGEON_PEA', 'toor': 'PIGEON_PEA',
    'groundnut': 'GROUNDNUT', 'peanut': 'GROUNDNUT', 'mungfali': 'GROUNDNUT',
    'mustard': 'MUSTARD', 'sarso': 'MUSTARD', 'sarson': 'MUSTARD',
    'potato': 'POTATO', 'aloo': 'POTATO',
    'tomato': 'TOMATO', 'tamatar': 'TOMATO',
    'onion': 'ONION', 'pyaz': 'ONION',
    'vegetables': 'VEGETABLES', 'veggies': 'VEGETABLES', 'sabzi': 'VEGETABLES',
    'pulses': 'PULSES', 'dal': 'PULSES', 'daal': 'PULSES',
    'millets': 'MILLETS', 'bajra': 'MILLETS', 'jowar': 'MILLETS', 'ragi': 'MILLETS'
  };

  const seasonKeywords = {
    'kharif': 'KHARIF',
    'rabi': 'RABI',
    'summer': 'SUMMER',
    'zaid': 'SUMMER',
    'monsoon': 'KHARIF',
    'winter': 'RABI',
    'year-round': 'ALL_SEASONS',
    'year round': 'ALL_SEASONS',
    'yearround': 'ALL_SEASONS',
    'all seasons': 'ALL_SEASONS',
    'perennial': 'ALL_SEASONS'
  };

  const result = {
    crops: [],
    cropSeasons: {},
    signals: {}
  };

  let normalized = text
    .replace(/\bfor\b/gi, ' ')
    .replace(/\bin\b/gi, ' ')
    .replace(/[-_.]/g, ' ')
    .replace(/\(/g, ' ')
    .replace(/\)/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const segments = normalized.split(/[,;\n]/).map(s => s.trim()).filter(Boolean);

  for (let segment of segments) {
    let segmentSeason = null;
    for (const [keyword, season] of Object.entries(seasonKeywords)) {
      const colonPattern = new RegExp(`^${keyword}\\s*:`, 'i');
      if (colonPattern.test(segment)) {
        segmentSeason = season;
        segment = segment.replace(colonPattern, '').trim();
        break;
      }
    }

    const tokens = segment.split(/\s+and\s+|\s{2,}/).map(t => t.trim()).filter(Boolean);
    
    for (const token of tokens) {
      const words = token.split(/\s+/);
      const detectedCrops = [];
      const detectedSeasons = [];
      
      words.forEach(word => {
        for (const [pattern, cropCode] of Object.entries(cropMap)) {
          if (word === pattern || word === pattern + 's') {
            if (!detectedCrops.includes(cropCode)) {
              detectedCrops.push(cropCode);
            }
          }
        }
        
        for (const [keyword, season] of Object.entries(seasonKeywords)) {
          if (word === keyword) {
            if (!detectedSeasons.includes(season)) {
              detectedSeasons.push(season);
            }
          }
        }
      });

      if (segmentSeason) {
        detectedSeasons.push(segmentSeason);
      }

      if (detectedSeasons.includes('ALL_SEASONS')) {
        detectedSeasons.length = 0;
        detectedSeasons.push('KHARIF', 'RABI', 'SUMMER');
      }

      detectedCrops.forEach(crop => {
        if (!result.crops.includes(crop)) {
          result.crops.push(crop);
        }
        
        if (detectedSeasons.length > 0) {
          if (!result.cropSeasons[crop]) {
            result.cropSeasons[crop] = [];
          }
          detectedSeasons.forEach(season => {
            if (!result.cropSeasons[crop].includes(season)) {
              result.cropSeasons[crop].push(season);
            }
          });
        }
      });
    }
  }

  if (result.crops.includes('RICE')) {
    result.signals['CROP_RICE_DETECTED'] = { value: 'YES', confidence: 0.9 };
  }
  if (result.crops.includes('WHEAT')) {
    result.signals['CROP_WHEAT_DETECTED'] = { value: 'YES', confidence: 0.9 };
  }
  if (result.crops.includes('MAIZE')) {
    result.signals['CROP_MAIZE_DETECTED'] = { value: 'YES', confidence: 0.9 };
  }
  if (result.crops.includes('SUGARCANE')) {
    result.signals['CROP_SUGARCANE_DETECTED'] = { value: 'YES', confidence: 0.9 };
  }
  
  if (result.crops.length >= 4) {
    result.signals['CROP_DIVERSITY'] = { value: 'VERY_HIGH', confidence: 0.9 };
  } else if (result.crops.length === 3) {
    result.signals['CROP_DIVERSITY'] = { value: 'HIGH', confidence: 0.8 };
  } else if (result.crops.length === 2) {
    result.signals['CROP_DIVERSITY'] = { value: 'MEDIUM', confidence: 0.8 };
  } else if (result.crops.length === 1) {
    result.signals['CROP_DIVERSITY'] = { value: 'LOW', confidence: 0.8 };
  }

  const allSeasons = new Set();
  Object.values(result.cropSeasons).forEach(seasons => {
    seasons.forEach(s => allSeasons.add(s));
  });
  if (allSeasons.size === 3) {
    result.signals['CROPPING_INTENSITY'] = { value: 'HIGH', confidence: 0.8 };
  } else if (allSeasons.size === 2) {
    result.signals['CROPPING_INTENSITY'] = { value: 'MEDIUM', confidence: 0.7 };
  }

  const kharifCrops = Object.keys(result.cropSeasons).filter(c => 
    result.cropSeasons[c].includes('KHARIF')
  );
  if (kharifCrops.length > 0) {
    result.signals['KHARIF_ACTIVE'] = { value: 'YES', confidence: 0.9 };
  }

  const rabiCrops = Object.keys(result.cropSeasons).filter(c => 
    result.cropSeasons[c].includes('RABI')
  );
  if (rabiCrops.length > 0) {
    result.signals['RABI_ACTIVE'] = { value: 'YES', confidence: 0.9 };
  }

  console.log('[Q] Parsed crop answer:', result);
  return result;
}


function formatParsedCropAnswer_(parsed) {
  if (!parsed || !parsed.crops || parsed.crops.length === 0) return null;
  
  const entries = [];
  parsed.crops.forEach(crop => {
    const seasons = parsed.cropSeasons[crop] || [];
    if (seasons.length > 0) {
      entries.push(`${crop}:${seasons.join('+')}`);
    } else {
      entries.push(`${crop}:UNKNOWN`);
    }
  });
  return entries.join(',');
}



function validateAnswer_(answerRaw) {
  if (answerRaw === null || answerRaw === undefined) return false;
  
  // ✅ Trim whitespace and check if empty
  const trimmed = String(answerRaw).trim();
  if (trimmed === '') return false;
  
  return true;
}


 function applyDerivationsForQuestion_(qid, answerRaw) {
  const rules = CPOSL.q.idx.qDerivByWhenQ.get(qid) || [];
  rules.forEach(rule => {
    if (!toBool(rule.Is_Active)) return;

    const op = String(rule.When_Operator || '').trim().toUpperCase();
    const whenVal = String(rule.When_Value || '').trim();
    const signalKey = String(rule.Then_Signal_Key || '').trim();
    const signalVal = String(rule.Then_Signal_Value || '').trim();
    const conf = toNum(rule.Then_Signal_Score) ?? 1.0;
    const priority = toNum(rule.Priority) ?? 50;

    if (!signalKey) return;

    let matches = false;
    if (op === 'EQUALS' || op === '=') {
      matches = (String(answerRaw).trim() === whenVal);
    } else if (op === '!=' || op === 'NOT_EQUALS') {
      matches = (String(answerRaw).trim() !== whenVal);
    } else if (op === 'IN' || op === 'CONTAINS') {
      matches = String(answerRaw).toLowerCase().includes(whenVal.toLowerCase());
    } else if (op === '>') {
      matches = toNum(answerRaw) > toNum(whenVal);
    } else if (op === '>=') {
      matches = toNum(answerRaw) >= toNum(whenVal);
    } else if (op === '<') {
      matches = toNum(answerRaw) < toNum(whenVal);
    } else if (op === '<=') {
      matches = toNum(answerRaw) <= toNum(whenVal);
    }

    if (matches) {
      const existing = CPOSL.qState.signals[signalKey];
      if (!existing || conf > existing.confidence || (conf === existing.confidence && priority > existing.priority)) {
        CPOSL.qState.signals[signalKey] = {
          value: signalVal,
          confidence: conf,
          sourceQ: qid,
          priority: priority
        };
      }
    }
  });
}



function applyRoutingForQuestion_(qid, answerRaw) {
  rebuildSignalsFromAllAnswers_();
  
  const rules = CPOSL.q.idx.qRoutesByCurrentQ.get(qid) || [];
  const sortedRules = rules.filter(r => toBool(r.Is_Active)).sort((a, b) => (toNum(a.Priority) ?? 9999) - (toNum(b.Priority) ?? 9999));

  sortedRules.forEach(rule => {
    const sigKey = String(rule.Condition_Signal_Key || '').trim();
    const op = String(rule.Condition_Operator || '').trim().toUpperCase();
    const condVal = String(rule.Condition_Value || '').trim();
    const nextQ = String(rule.Next_Question_ID || '').trim();
    const action = String(rule.Route_Action || 'ASK').trim().toUpperCase();

    let matches = false;

    if (sigKey && sigKey !== 'ANY') {
      const signal = CPOSL.qState.signals[sigKey];
      if (!signal) return;

      const sigVal = String(signal.value || '').trim();
      
      if (op === 'EQUALS' || op === '=') {
        matches = (sigVal === condVal);
      } else if (op === '!=') {
        matches = (sigVal !== condVal);
      } else if (op === 'CONTAINS') {
        matches = sigVal.toLowerCase().includes(condVal.toLowerCase());
      }
    } else if (sigKey === 'ANY' || !sigKey) {
      matches = true;
    }

    if (matches) {
      if (action === 'END' || action === 'END_IF_MIN_MET') {
        if (CPOSL.qState.answeredCount >= CPOSL.qState.minTarget) {
          CPOSL.qState.stop = true;
        }
      } else if (action === 'SKIP_TO') {
        CPOSL.qState.queue = [];
        if (nextQ && !CPOSL.qState.answered[nextQ] && nextQ !== qid) {
          CPOSL.qState.queue.push(nextQ);
          console.log(`[Q] Route SKIP_TO: ${nextQ}`);
        }
      } else if (action === 'ASK') {
        if (nextQ && !CPOSL.qState.answered[nextQ] && !CPOSL.qState.queue.includes(nextQ) && nextQ !== qid) {
          CPOSL.qState.queue.unshift(nextQ);
          console.log(`[Q] Route ASK (drill-down): ${nextQ}`);
        }
      } else if (action === 'ESCALATE_EXPERT') {
        console.log(`[Q] Escalate to expert: ${nextQ}`);
      }
    }
  });
}




    function rebuildSignalsFromAllAnswers_() {
      CPOSL.qState.signals = {};
      Object.keys(CPOSL.qState.answered).forEach(qid => {
        const ans = CPOSL.qState.answered[qid];
        if (ans && ans.Answer_Normalized !== 'SKIPPED') {
          applyDerivationsForQuestion_(qid, ans.Answer_Raw);
        }
      });
    }

    function applySignalMappingsToLiteFactors_() {
  const mappings = CPOSL.q.signalToLiteMap.filter(m => toBool(m.Is_Active));
  const mapped = [];

  mappings.forEach(m => {
    const sigKey = String(m.Signal_Key || '').trim();
    const varNameRaw = String(m.Variable_Name || '').trim();
    const classLabelRaw = String(m.Class_Label || '').trim();
    const conf = toNum(m.Confidence_0_1) ?? 0.8;

    if (!sigKey || !varNameRaw || !classLabelRaw) return;

    const signal = CPOSL.qState.signals[sigKey];
    if (!signal) return;

    const varKey = normKey_(varNameRaw);
    const factor = CPOSL.idx.boundsByVar.get(varKey);
    if (!factor) {
      console.warn(`[Q] Signal ${sigKey} maps to unknown variable: ${varNameRaw}`);
      return;
    }

    const classKey = normKey_(classLabelRaw);
    const classRow = factor.classes.find(c => c.Class_Label === classKey);
    if (!classRow) {
      console.warn(`[Q] Signal ${sigKey} maps to unknown class: ${classLabelRaw} for var ${varNameRaw}`);
      return;
    }

    computeFromClassLabel_(factor, classLabelRaw, conf);
    mapped.push({
      signal: sigKey,
      variable: factor.Variable_Name_Display,
      classLabel: classRow.Class_Label_Display,
      confidence: conf
    });
  });

  const derivedBox = document.getElementById('qDerivedBox');
  if (derivedBox) {
    let html = '';
    
    const q_a1 = CPOSL.qState.answered['Q_A1'];
    if (q_a1 && q_a1.Parsed_Data) {
      const parsed = q_a1.Parsed_Data;
      html += '<div style="margin-bottom:12px"><b>Detected Crops:</b></div>';
      if (parsed.crops.length > 0) {
        html += '<div class="chips">';
        parsed.crops.forEach(crop => {
          const seasons = parsed.cropSeasons[crop] || [];
          const seasonText = seasons.length > 0 ? seasons.join(', ') : 'Season unknown';
          html += `<span class="chip"><span class="k">${escapeHtml(crop)}</span> ${escapeHtml(seasonText)}</span>`;
        });
        html += '</div>';
      } else {
        html += '<div class="small">No crops detected.</div>';
      }
    }
    
    html += '<div style="margin-top:12px"><b>Signals Derived:</b></div>';
    const sigKeys = Object.keys(CPOSL.qState.signals);
    if (sigKeys.length) {
      html += '<div class="chips">';
      sigKeys.forEach(k => {
        const sig = CPOSL.qState.signals[k];
        html += `<span class="chip"><span class="k">${escapeHtml(k)}</span> ${escapeHtml(sig.value)} (conf=${sig.confidence.toFixed(2)})</span>`;
      });
      html += '</div>';
    } else {
      html += '<div class="small">No signals derived yet.</div>';
    }

    html += '<div style="margin-top:12px"><b>Auto-filled Lite Factors:</b></div>';
    if (mapped.length) {
      html += '<div class="chips">';
      mapped.forEach(m => {
        html += `<span class="chip"><span class="k">${escapeHtml(m.variable)}</span> → ${escapeHtml(m.classLabel)} (conf=${m.confidence.toFixed(2)})</span>`;
      });
      html += '</div>';
    } else {
      html += '<div class="small">No factors mapped yet.</div>';
    }

    derivedBox.innerHTML = html;
  }

  return mapped;
}


function updateQuestionnaireUIState_() {
  const btnStart = document.getElementById('btnQStart');
  const btnBack = document.getElementById('btnQBack');
  const btnSkip = document.getElementById('btnQSkip');
  const btnNext = document.getElementById('btnQNext');
  const btnFinish = document.getElementById('btnQFinish');
  const progress = document.getElementById('qProgress');

  // ✅ NEW: Get current language
  const lang = CPOSL.language || 'EN';
  const inProgress = CPOSL.qState.current !== null;
  const canGoBack = CPOSL.qState.history.length > 0;
  const answerValid = validateAnswer_(readAnswerFromUI_());
  const canFinish = CPOSL.qState.answeredCount >= CPOSL.qState.minTarget || CPOSL.qState.stop;

  if (btnStart) {
    btnStart.disabled = inProgress;
    // ✅ NEW: Localized button text
    btnStart.textContent = lang === 'HI' ? 'शुरू करें' : 'Start';
  }
  if (btnBack) {
    btnBack.disabled = !inProgress || !canGoBack;
    // ✅ NEW: Localized button text
    btnBack.textContent = lang === 'HI' ? 'पीछे' : 'Back';
  }
  if (btnSkip) {
    btnSkip.disabled = !inProgress;
    // ✅ NEW: Localized button text
    btnSkip.textContent = lang === 'HI' ? 'छोड़ें' : 'Skip';
  }
  if (btnNext) {
    btnNext.disabled = !inProgress || !answerValid;
    // ✅ NEW: Localized button text
    btnNext.textContent = lang === 'HI' ? 'अगला' : 'Next';
  }
  if (btnFinish) {
    btnFinish.disabled = !inProgress || !canFinish;
    // ✅ NEW: Localized button text
    btnFinish.textContent = lang === 'HI' ? 'समाप्त' : 'Finish';
  }

  if (progress) {
    const target = CPOSL.qState.minTarget;
    const answered = CPOSL.qState.answeredCount;
    const pct = Math.min(100, Math.round((answered / target) * 100));
    // ✅ NEW: Localized progress text
    if (lang === 'HI') {
      progress.textContent = `उत्तर दिए ${answered} / लक्ष्य ${target} (${pct}%)`;
    } else {
      progress.textContent = `Answered ${answered} / target ${target} (${pct}%)`;
    }
  }
}



    function computeFromClassLabel_(factor, classLabel, confidence) {
      const varName = factor.Variable_Name;
      const classKey = normKey_(classLabel);
      const classRow = (factor.classes || []).find(c => c.Class_Label === classKey) || null;
      const classDisplay = classRow ? classRow.Class_Label_Display : classLabel;

      CPOSL.selections[varName] = {
        Variable_Name: varName,
        Variable_Name_Display: factor.Variable_Name_Display || varName,
        Factor_ID: factor.Factor_ID,
        Factor_Category: factor.Factor_Category,
        Factor_Category_Display: factor.Factor_Category_Display,
        Factor_Display_Name: factor.Factor_Display_Name,
        Unit: factor.Unit || '',
        Observed_Value: CPOSL.selections[varName]?.Observed_Value ?? null,
        Class_Order: classRow ? classRow.Class_Order : null,
        Class_Label: classKey,
        Class_Label_Display: classDisplay,
        Confidence_0_1: confidence
      };

      CPOSL.computed[varName] = {};
      for (const p of CPOSL.PATHWAYS) {
        const dKey = `${varName}||${p}||${classKey}`;
        const wKey = `${varName}||${p}`;

        const dRow = CPOSL.idx.desirByVarPathClass.get(dKey) || null;
        const w = CPOSL.idx.weightByVarPath.get(wKey);

        const desir = dRow ? dRow.d : null;
        const shape = dRow ? dRow.shape : '';
        const ctx = dRow ? dRow.ctx : '';

        const score = (Number.isFinite(desir) && Number.isFinite(w)) ? (desir * w) : null;

        CPOSL.computed[varName][p] = { desir, w, score, shape, ctx };
      }
    }

    // ---------------------------
    // Questionnaire navigation
    // ---------------------------
function qStart() {
  CPOSL.qState.sessionId = 'Q-' + Date.now();
  CPOSL.qState.answered = {};
  CPOSL.qState.signals = {};
  CPOSL.qState.queue = [...CPOSL.q.idx.startQuestions];
  CPOSL.qState.history = [];
  CPOSL.qState.current = null;
  CPOSL.qState.answeredCount = 0;
  CPOSL.qState.stop = false;

  if (!CPOSL.qState.queue.length) {
    document.getElementById('qQuestionText').textContent = 'No start questions configured.';
    setStatus(false, 'No start questions');
    return;
  }

  CPOSL.qState.current = CPOSL.qState.queue.shift();
  renderQuestionUI_();
  updateQuestionnaireUIState_();
  setStatus(true, 'Questionnaire started');
}


 function qNext() {
  const qid = CPOSL.qState.current;
  if (!qid) return;

  const answerRaw = readAnswerFromUI_();
  if (!validateAnswer_(answerRaw)) {
    setStatus(false, 'Please answer the question');
    return;
  }

  let parsedData = null;
  let normalizedAnswer = answerRaw;
  
  if (qid === 'Q_A1') {
    parsedData = parseCropAnswer_(answerRaw);
    if (parsedData && parsedData.crops.length > 0) {
      normalizedAnswer = formatParsedCropAnswer_(parsedData);
      
      Object.entries(parsedData.signals || {}).forEach(([key, sig]) => {
        CPOSL.qState.signals[key] = {
          value: sig.value,
          confidence: sig.confidence,
          sourceQ: qid,
          priority: 10
        };
      });
      
      console.log('[Q] Parsed crops:', parsedData);
    }
  }

  CPOSL.qState.answered[qid] = {
    Answer_Raw: answerRaw,
    Answer_Codes: normalizedAnswer,
    Answer_Normalized: normalizedAnswer,
    Parsed_Data: parsedData
  };
  
  CPOSL.qState.answeredCount = Object.keys(CPOSL.qState.answered).filter(k => 
    CPOSL.qState.answered[k].Answer_Normalized !== 'SKIPPED'
  ).length;

  applyDerivationsForQuestion_(qid, normalizedAnswer);
  applyRoutingForQuestion_(qid, normalizedAnswer);

  if (CPOSL.qState.queue.length === 0) {
    const nextSeqQuestion = findNextSequentialQuestion_(qid);
    if (nextSeqQuestion) {
      CPOSL.qState.queue.push(nextSeqQuestion);
      console.log(`[Q] Auto-added next required: ${nextSeqQuestion}`);
    }
  }

  CPOSL.qState.history.push(qid);

  const minTargetMet = CPOSL.qState.answeredCount >= CPOSL.qState.minTarget;
  const maxCapReached = CPOSL.qState.answeredCount >= CPOSL.qState.maxCap;
  
  if (CPOSL.qState.queue.length === 0 || maxCapReached) {
    CPOSL.qState.current = null;
    if (minTargetMet || maxCapReached) {
      document.getElementById('qQuestionText').textContent = `${CPOSL.qState.answeredCount} questions answered. Click Finish to complete.`;
    } else {
      document.getElementById('qQuestionText').textContent = `Answered ${CPOSL.qState.answeredCount}/${CPOSL.qState.minTarget}. No more questions. Click Finish.`;
    }
    document.getElementById('qAnswerBox').innerHTML = '';
  } else {
    CPOSL.qState.current = CPOSL.qState.queue.shift();
    renderQuestionUI_();
  }

  updateQuestionnaireUIState_();
}




function qBack() {
  if (CPOSL.qState.history.length === 0) return;

  const prevQ = CPOSL.qState.history.pop();
  if (CPOSL.qState.current) {
    CPOSL.qState.queue.unshift(CPOSL.qState.current);
  }
  CPOSL.qState.current = prevQ;
  renderQuestionUI_();
  updateQuestionnaireUIState_();
}


    function qSkip() {
  const qid = CPOSL.qState.current;
  if (!qid) return;

  CPOSL.qState.answered[qid] = {
    Answer_Raw: '',
    Answer_Codes: '',
    Answer_Normalized: 'SKIPPED'
  };

  CPOSL.qState.history.push(qid);

  if (CPOSL.qState.queue.length === 0) {
    const nextSeqQuestion = findNextSequentialQuestion_(qid);
    if (nextSeqQuestion) {
      CPOSL.qState.queue.push(nextSeqQuestion);
      console.log(`[Q] Auto-added next required after skip: ${nextSeqQuestion}`);
    }
  }

  const minTargetMet = CPOSL.qState.answeredCount >= CPOSL.qState.minTarget;
  const maxCapReached = CPOSL.qState.answeredCount >= CPOSL.qState.maxCap;

  if (CPOSL.qState.queue.length === 0 || maxCapReached) {
    CPOSL.qState.current = null;
    if (minTargetMet || maxCapReached) {
      document.getElementById('qQuestionText').textContent = `${CPOSL.qState.answeredCount} questions answered. Click Finish.`;
    } else {
      document.getElementById('qQuestionText').textContent = `Answered ${CPOSL.qState.answeredCount}/${CPOSL.qState.minTarget}. No more questions. Click Finish.`;
    }
    document.getElementById('qAnswerBox').innerHTML = '';
  } else {
    CPOSL.qState.current = CPOSL.qState.queue.shift();
    renderQuestionUI_();
  }

  updateQuestionnaireUIState_();
}


    function qFinish() {
      rebuildSignalsFromAllAnswers_();
      const mapped = applySignalMappingsToLiteFactors_();

      renderFactorForm();
      renderNotesBox();

      const payload = {
        session: {
          Session_ID: CPOSL.qState.sessionId,
          Mode: CPOSL.qState.mode,
          Min_Target: CPOSL.qState.minTarget,
          Max_Cap: CPOSL.qState.maxCap,
          Answered_Count: CPOSL.qState.answeredCount,
          Status: 'COMPLETED'
        },
        responses: Object.keys(CPOSL.qState.answered).map(qid => ({
          Question_ID: qid,
          Answer_Raw: CPOSL.qState.answered[qid].Answer_Raw,
          Answer_Codes: CPOSL.qState.answered[qid].Answer_Codes,
          Derived_Signals_JSON: ''
        })),
        summary: {
          signalsCount: Object.keys(CPOSL.qState.signals).length,
          mappedFactors: mapped.length
        }
      };

      document.getElementById('qNavStatus').textContent = 'Saving session...';

      if (typeof google !== 'undefined' && google.script && google.script.run) {
        google.script.run
          .withSuccessHandler(res => {
            document.getElementById('qNavStatus').innerHTML = `<span style="color:var(--ok)">Session saved: ${res.Session_ID || ''}</span>`;
          })
          .withFailureHandler(err => {
            document.getElementById('qNavStatus').innerHTML = `<span style="color:var(--warn)">Save failed: ${err?.message || err}</span>`;
          })
          .saveCPOSQuestionnaireSession(payload);
      } else {
        document.getElementById('qNavStatus').textContent = 'Save unavailable (local mode)';
      }

      setStatus(true, `Questionnaire complete • ${mapped.length} factors auto-filled`);
      goStep(1);
    }

    // ---------------------------
    // Classification from bounds
    // ---------------------------
    function classifyValue_(factor, observedValue) {
      if (observedValue === null || !Number.isFinite(observedValue)) return null;

      for (const c of (factor.classes || [])) {
        const lo = c.Lower_Bound;
        const hi = c.Upper_Bound;

        const passLo = (lo === null) ? true : (c.Lower_Inclusive ? (observedValue >= lo) : (observedValue > lo));
        const passHi = (hi === null) ? true : (c.Upper_Inclusive ? (observedValue <= hi) : (observedValue < hi));

        if (passLo && passHi) return { Class_Order: c.Class_Order, Class_Label: c.Class_Label, Class_Label_Display: c.Class_Label_Display };
      }
      return null;
    }

    // ---------------------------
    // UI render (group by Factor_Category)
    // ---------------------------
    function renderFactorForm() {
      const host = document.getElementById('factorForm');
      host.innerHTML = '';

      if (!CPOSL.idx.factorsByCat.size) {
        host.innerHTML = `<div class="mutedBox" style="grid-column:1/-1">No factors loaded.</div>`;
        updateEvalGateUI_();
        return;
      }

      for (const entry of CPOSL.idx.factorsByCat.values()) {
        const cat = entry.label;
        const factors = entry.factors;
        const catField = document.createElement('div');
        catField.className = 'field';
        catField.style.background = 'rgba(245, 238, 220, 1)';
        catField.style.borderColor = 'rgba(214, 198, 160, 1)';
        catField.style.gridColumn = '1/-1';
        catField.innerHTML = `<label><span><b>${escapeHtml(cat)}</b></span><span class="cat">Factor_Category</span></label>
          <div class="small">Enter values for factors in this category. Class_Label will be auto-derived from Bounds.</div>`;
        host.appendChild(catField);

        for (const f of factors) {
          const field = document.createElement('div');
          field.className = 'field';

          const id = 'inp_' + f.Variable_Name.replaceAll(/[^a-zA-Z0-9]+/g,'_');
          const cur = CPOSL.selections[f.Variable_Name] || {};
          const curVal = (cur.Observed_Value ?? '');

          field.innerHTML = `
            <label>
              <span>${escapeHtml(f.Factor_Display_Name || f.Variable_Name_Display || f.Variable_Name)}</span>
              <span class="cat">${escapeHtml(f.Unit || '—')}</span>
            </label>
            <input id="${id}" type="number" step="any" placeholder="Observed value" value="${escapeHtml(curVal)}">
            <div class="small" style="margin-top:8px">
              <b>Class:</b> <span id="${id}_cls">${escapeHtml(cur.Class_Label_Display || '—')}</span>
            </div>
          `;

          host.appendChild(field);

          const inp = field.querySelector('#' + id);
          inp.addEventListener('input', () => {
            const raw = inp.value;
            const val = raw === '' ? null : Number(raw);
            onValueChange_(f, val);
            const clsEl = document.getElementById(id + '_cls');
            if (clsEl) clsEl.textContent = CPOSL.selections[f.Variable_Name]?.Class_Label_Display || '—';
            renderNotesBox();
            updateEvalGateUI_();
          });
        }
      }

      renderNotesBox();
      updateEvalGateUI_();
    }

    function onValueChange_(factor, observedValue) {
      const varName = factor.Variable_Name;
      const classified = classifyValue_(factor, observedValue);

      CPOSL.selections[varName] = {
        Variable_Name: varName,
        Variable_Name_Display: factor.Variable_Name_Display || varName,
        Factor_ID: factor.Factor_ID,
        Factor_Category: factor.Factor_Category,
        Factor_Category_Display: factor.Factor_Category_Display,
        Factor_Display_Name: factor.Factor_Display_Name,
        Unit: factor.Unit || '',
        Observed_Value: observedValue,
        Class_Order: classified ? classified.Class_Order : null,
        Class_Label: classified ? classified.Class_Label : null,
        Class_Label_Display: classified ? classified.Class_Label_Display : null
      };

      CPOSL.computed[varName] = {};
      for (const p of CPOSL.PATHWAYS) {
        const cls = classified?.Class_Label || '';
        const dKey = `${varName}||${p}||${cls}`;
        const wKey = `${varName}||${p}`;

        const dRow = CPOSL.idx.desirByVarPathClass.get(dKey) || null;
        const w = CPOSL.idx.weightByVarPath.get(wKey);

        const desir = dRow ? dRow.d : null;
        const shape = dRow ? dRow.shape : '';
        const ctx = dRow ? dRow.ctx : '';

        const score = (Number.isFinite(desir) && Number.isFinite(w)) ? (desir * w) : null;

        CPOSL.computed[varName][p] = { desir, w, score, shape, ctx };
      }
    }

    function countInputs_() {
      let c = 0;
      for (const k of Object.keys(CPOSL.selections)) {
        const sel = CPOSL.selections[k] || {};
        const v = sel.Observed_Value;
        if (v !== null && v !== undefined && v !== '' && Number.isFinite(Number(v))) {
          c++;
          continue;
        }
        if (sel.Class_Label) c++;
      }
      return c;
    }

    function updateEvalGateUI_() {
      const hint = document.getElementById('evalGateHint');
      const btn = document.getElementById('btnEvaluate');
      const n = countInputs_();

      const MIN_REQUIRED = 1;
      const ok = n >= MIN_REQUIRED;

      if (hint) {
        hint.textContent = ok
          ? `Ready to evaluate. Entered ${n} value(s).`
          : `Enter at least ${MIN_REQUIRED} value to evaluate.`;
      }
      if (btn) btn.disabled = !ok;
    }

    // ---------------------------
    // Explainability panel
    // ---------------------------
    function classifyFlagFromDesirability_(d) {
      if (d === null || d === undefined || isNaN(Number(d))) return { cls: 'flag-neutral', txt: 'NA' };
      const x = Number(d);
      if (x <= 0.33) return { cls: 'flag-bad', txt: 'Adverse' };
      if (x >= 0.67) return { cls: 'flag-good', txt: 'Supportive' };
      return { cls: 'flag-neutral', txt: 'Mixed' };
    }

    function renderNotesBox() {
      const box = document.getElementById('notesBox');
      if (!box) return;

      const parts = [];
      const vars = Object.keys(CPOSL.selections || {});
      vars.forEach(varName => {
        const sel = CPOSL.selections[varName] || {};
        if (!sel || !sel.Class_Label) return;

        const rows = CPOSL.PATHWAYS.map(p => {
          const c = CPOSL.computed?.[varName]?.[p] || {};
          const dOk = Number.isFinite(c.desir);
          const wOk = Number.isFinite(c.w);
          const sOk = Number.isFinite(c.score);

          const badge = classifyFlagFromDesirability_(dOk ? c.desir : null);

          const ctx = c.ctx ? ` — ${c.ctx}` : '';
          const shape = c.shape ? ` ${c.shape}` : '';

          return `- ${p}: d=${dOk ? c.desir.toFixed(2) : 'NA'}, w=${wOk ? c.w.toFixed(1) : 'NA'}, score=${sOk ? c.score.toFixed(2) : 'NA'}${shape} [${badge.txt}]${ctx}`;
        }).join('\n');

        parts.push(
          `${sel.Factor_Display_Name || sel.Variable_Name_Display || varName} (${sel.Variable_Name_Display || varName})\n` +
          `Observed_Value: ${sel.Observed_Value ?? '—'} ${sel.Unit || ''}\n` +
          `Class_Label: ${sel.Class_Label_Display || sel.Class_Label}\n` +
          `${rows}\n`
        );
      });

      box.textContent = parts.length
        ? parts.join('\n--------------------------------\n')
        : 'Enter values to view class, desirability, and pathway context here.';
    }

    // ---------------------------
    // Evaluation -> pathway screening (local compute)
    // ---------------------------
    function computePathwayResults_() {
      const results = {};
      const pathways = CPOSL.PATHWAYS;

      const acc = {};
      pathways.forEach(p => acc[p] = { sumScore:0, sumW:0, n:0, bad:[], good:[], mrvBad:false, mrvGood:true });

      for (const varName of Object.keys(CPOSL.computed || {})) {
        const sel = CPOSL.selections[varName] || {};
        const hasInput = sel && sel.Class_Label && (Number.isFinite(Number(sel.Observed_Value)) || sel.Class_Label);
        if (!hasInput) continue;

        for (const p of pathways) {
          const c = CPOSL.computed[varName]?.[p] || {};
          const d = c.desir;
          const w = c.w;
          if (!Number.isFinite(d) || !Number.isFinite(w)) continue;

          acc[p].sumScore += (d * w);
          acc[p].sumW += w;
          acc[p].n += 1;

          const isMRV = String(sel.Factor_Category_Display || sel.Factor_Category || '').trim().toLowerCase() === 'mrv';
          if (isMRV) {
            if (d <= 0.33) acc[p].mrvBad = true;
            if (d < 0.67) acc[p].mrvGood = false;
          }

          if (d <= 0.33) acc[p].bad.push(`${sel.Factor_Display_Name || sel.Variable_Name_Display || varName} (${sel.Class_Label_Display || sel.Class_Label})`);
          if (d >= 0.67) acc[p].good.push(`${sel.Factor_Display_Name || sel.Variable_Name_Display || varName} (${sel.Class_Label_Display || sel.Class_Label})`);
        }
      }

      for (const p of pathways) {
        const a = acc[p] || { sumScore:0,sumW:0,n:0,bad:[],good:[],mrvBad:false,mrvGood:true };
        const avg = a.sumW > 0 ? (a.sumScore / a.sumW) : 0;

        let eligibility = 'CONDITIONAL';
        if (avg >= 0.67) eligibility = 'YES';
        else if (avg <= 0.33) eligibility = 'NO';

        let priority = 'MEDIUM';
        if (avg >= 0.75 && a.n >= 3) priority = 'HIGH';
        else if (avg < 0.50) priority = 'LOW';

        let mrv_tier = 'STANDARD';
        if (a.mrvBad) mrv_tier = 'HIGH';
        else if (a.n && a.mrvGood && (String(p) !== '')) mrv_tier = 'LIGHT';

        const reasons = [];
        if (a.good.length) reasons.push(`Supportive factors: ${a.good.slice(0,3).join('; ')}`);
        if (a.bad.length) reasons.push(`Adverse factors: ${a.bad.slice(0,3).join('; ')}`);
        if (!reasons.length) reasons.push('No desirability signals found for entered inputs.');

        const flags = a.bad.slice(0, 10);

        results[p] = {
          eligibility,
          priority,
          mrv_tier,
          reasons,
          flags,
          final_text: `Score=${avg.toFixed(3)} (n=${a.n}, weight_sum=${a.sumW.toFixed(1)})`
        };
      }

      return results;
    }

    function evaluateAndGo() {
      const n = countInputs_();
      if (n < 1) {
        setStatus(false, 'Enter at least 1 value before evaluating.');
        setTimeout(() => setStatus(true, 'Ready'), 1200);
        return;
      }

      setStatus(true, 'Evaluating…');
      const results = computePathwayResults_();
      CPOSL.lastResults = results;

      console.log('[CPOS] evaluation result', results);

      safeCall_('renderSelectionRecap', renderSelectionRecap);
      safeCall_('renderScreening', () => renderScreening(results));
      safeCall_('renderMRVStrip', () => renderMRVStrip(results));
      safeCall_('renderDecisionSummary', () => renderDecisionSummary(results));

      setStatus(true, 'Evaluation complete');
      goStep(2);
    }

    function renderSelectionRecap() {
      const box = document.getElementById('selectionRecap');
      box.innerHTML = '';
      const sels = CPOSL.selections || {};

      let any = false;
      Object.keys(sels).forEach(varName => {
        const s = sels[varName];
        if (!s || !s.Class_Label) return;
        const hasVal = s.Observed_Value !== null && s.Observed_Value !== undefined && s.Observed_Value !== '';
        any = true;
        const label = s.Factor_Display_Name || s.Variable_Name_Display || varName;
        const val = hasVal
          ? `${s.Observed_Value}${s.Unit ? ' ' + s.Unit : ''} → ${s.Class_Label_Display || s.Class_Label}`
          : `Class only → ${s.Class_Label_Display || s.Class_Label}`;
        box.appendChild(makeChip(label, val));
      });

      if (!any) box.innerHTML = '<div class="small">No inputs.</div>';
    }

    function pillForEligibility(e){
      if (e === 'YES') return makePill('ok', 'YES');
      if (e === 'NO') return makePill('bad', 'NO');
      return makePill('warn', 'CONDITIONAL');
    }
    function pillForPriority(p){
      if (p === 'HIGH') return makePill('ok', 'PRIORITY: HIGH');
      if (p === 'LOW') return makePill('bad', 'PRIORITY: LOW');
      return makePill('blue', 'PRIORITY: MEDIUM');
    }
    function pillForMRV(m){
      if (m === 'HIGH') return makePill('warn', 'MRV: HIGH');
      if (m === 'LIGHT') return makePill('ok', 'MRV: LIGHT');
      return makePill('blue', 'MRV: STANDARD');
    }

    function renderScreening(results) {
      const grid = document.getElementById('screeningGrid');
      if (!grid) return;
      grid.innerHTML = '';

      CPOSL.PATHWAYS.forEach(k => {
        const r = results[k] || {};
        const card = document.createElement('div');
        card.className = 'pathCard';
        if (k === 'RP-SOC') card.classList.add('path-rp');
        else if (k === 'AWD-CH₄') card.classList.add('path-awd');
        else if (k === 'BIOCHAR') card.classList.add('path-bio');
        else if (k === 'ERW') card.classList.add('path-erw');

        const top = document.createElement('div');
        top.className = 'pathTop';
        const name = document.createElement('h4');
        name.className = 'pathName';
        name.textContent = k;
        top.appendChild(name);

        const meta = document.createElement('div');
        meta.className = 'pathMeta';
        meta.appendChild(pillForEligibility(r.eligibility));
        meta.appendChild(pillForPriority(r.priority));
        meta.appendChild(pillForMRV(r.mrv_tier));
        top.appendChild(meta);

        card.appendChild(top);

        const reasons = r.reasons || [];
        if (reasons.length) {
          const ul = document.createElement('ul');
          ul.className = 'list';
          reasons.forEach(txt => {
            const li = document.createElement('li');
            li.textContent = txt;
            ul.appendChild(li);
          });
          card.appendChild(ul);
        }

        grid.appendChild(card);
      });
    }

    function renderMRVStrip(results) {
      const box = document.getElementById('mrvStrip');
      const tiers = Object.values(results || {}).map(r => r?.mrv_tier || 'STANDARD');
      let level = 'STANDARD';
      if (tiers.includes('HIGH')) level = 'HIGH';
      else if (tiers.includes('LIGHT')) level = 'LIGHT';

      let msg = '';
      if (level === 'HIGH') msg = 'MRV focus: High-tier monitoring likely needed (MRV category indicates adverse conditions for at least one pathway).';
      else if (level === 'LIGHT') msg = 'MRV focus: Light MRV feasible (MRV category supportive for current inputs).';
      else msg = 'MRV focus: Standard MRV is generally sufficient for current inputs.';

      box.innerHTML = `<b style="color:rgba(47,111,181,0.95)">MRV Focus Strip</b><div style="margin-top:6px">${escapeHtml(msg)}</div>`;
    }

    function buildDecisionSummary(results) {
      const pathways = ["RP-SOC","AWD-CH₄","BIOCHAR","ERW"];
      const prRank = { "HIGH":3,"MEDIUM":2,"LOW":1 };
      const mrvRank = { "LIGHT":3,"STANDARD":2,"HIGH":1 };

      const items = pathways.map(k => {
        const r = results[k] || {};
        return {
          k,
          eligibility: r.eligibility || "CONDITIONAL",
          priority: r.priority || "MEDIUM",
          mrv_tier: r.mrv_tier || "STANDARD",
          reasons: r.reasons || [],
          flags: r.flags || []
        };
      });

      const recommended = items
        .filter(x => x.eligibility === "YES")
        .sort((a,b) => prRank[b.priority] - prRank[a.priority] || mrvRank[b.mrv_tier] - mrvRank[a.mrv_tier])
        .map(x => x.k);

      const conditional = items
        .filter(x => x.eligibility === "CONDITIONAL")
        .sort((a,b) => prRank[b.priority] - prRank[a.priority] || mrvRank[b.mrv_tier] - mrvRank[a.mrv_tier])
        .map(x => x.k);

      const excluded = items.filter(x => x.eligibility === "NO").map(x => x.k);

      const riskFlags = [...new Set(items.flatMap(x => x.flags || []))].slice(0, 12);

      const topReasons = {};
      items.forEach(x => {
        if ((x.reasons || []).length) topReasons[x.k] = x.reasons.slice(0, 2);
      });

      const headParts = [];
      if (recommended.length) headParts.push(`${recommended.join(" + ")} recommended`);
      if (conditional.length) headParts.push(`${conditional.join(" + ")} conditional`);
      if (excluded.length) headParts.push(`${excluded.join(" + ")} excluded`);
      const headline = headParts.join("; ") || "No decision available.";

      return { recommended, conditional, excluded, headline, topReasons, riskFlags };
    }

    function renderStackChips(elId, arr, label) {
      const box = document.getElementById(elId);
      if (!box) return;
      box.innerHTML = '';
      if (!arr || !arr.length) {
        box.innerHTML = `<div class="small" style="color:var(--muted)">None</div>`;
        return;
      }
      arr.forEach(k => box.appendChild(makeChip(label, k)));
    }

    function renderDecisionSummary(results) {
      const sum = buildDecisionSummary(results);
      const headlineBox = document.getElementById('headlineBox');

      const reasonsBits = [];
      Object.keys(sum.topReasons || {}).forEach(k => {
        const rr = sum.topReasons[k] || [];
        if (!rr.length) return;
        reasonsBits.push(
          `<div style="margin-top:10px"><b>${escapeHtml(k)}</b><ul class="list">${rr.map(x => `<li>${escapeHtml(x)}</li>`).join('')}</ul></div>`
        );
      });

      const flagsBits = (sum.riskFlags || []).length
        ? `<div style="margin-top:10px"><b>Risk flags</b><div class="chips" style="margin-top:8px">${sum.riskFlags.map(f => `<span class="chip"><span class="k">Flag</span> ${escapeHtml(f)}</span>`).join('')}</div></div>`
        : '';

      headlineBox.innerHTML =
        `<div style="font-weight:1000; font-size:13px">${escapeHtml(sum.headline)}</div>` +
        (reasonsBits.length ? reasonsBits.join('') : `<div style="margin-top:10px;color:var(--muted)">No reasons triggered (with current inputs).</div>`) +
        flagsBits;

      renderStackChips('recStack', sum.recommended, 'Recommended');
      renderStackChips('condStack', sum.conditional, 'Conditional');
      renderStackChips('exclStack', sum.excluded, 'Excluded');
    }

    // ---------------------------
    // Actions
    // ---------------------------
    function clearSelections() {
      CPOSL.selections = {};
      CPOSL.computed = {};
      CPOSL.lastResults = null;
      renderFactorForm();
      renderSelectionRecap();
      document.getElementById('notesBox').textContent =
        'Enter values to view class, desirability, and pathway context here.';
      setStatus(true, 'Selections cleared');
    }

    function openSaveDrawer() {
      if (!CPOSL.lastResults) setStatus(false, 'Evaluate before saving.');
      else setStatus(true, 'Ready to save (optional)');
    }

    function fillDemoMeta(){
      document.getElementById('metaClientId').value = 'Default';
      document.getElementById('metaSiteId').value = 'SITE-001';
      document.getElementById('metaSiteName').value = 'Demo Site';
      document.getElementById('metaCropSystem').value = 'Rice paddy';
      document.getElementById('metaLat').value = '26.1234';
      document.getElementById('metaLon').value = '81.9876';
      document.getElementById('metaState').value = 'UP';
      document.getElementById('metaDistrict').value = 'Sonbhadra';
      document.getElementById('metaNotes').value = 'Demo assessment for CP-OS Lite UI test.';
    }

    function saveAssessment() {
      const out = document.getElementById('saveStatus');
      out.textContent = '';

      if (!CPOSL.lastResults) {
        out.textContent = 'Nothing to save (evaluate first).';
        return;
      }

      const payload = {
        Client_ID: document.getElementById('metaClientId').value || 'Default',
        Site_ID: document.getElementById('metaSiteId').value || '',
        Site_Name: document.getElementById('metaSiteName').value || '',
        Crop_System: document.getElementById('metaCropSystem').value || '',
        Latitude: document.getElementById('metaLat').value || '',
        Longitude: document.getElementById('metaLon').value || '',
        State: document.getElementById('metaState').value || '',
        District: document.getElementById('metaDistrict').value || '',
        selections: CPOSL.selections || {},
        results: CPOSL.lastResults || {},
        notes: document.getElementById('metaNotes').value || ''
      };

      out.textContent = 'Saving…';

      if (typeof google === 'undefined' || !google.script || !google.script.run) {
        out.textContent = 'Save unavailable (local mode).';
        return;
      }

      google.script.run
        .withSuccessHandler(res => {
          if (res && res.ok) {
            out.innerHTML = `<span style="color:rgba(58,143,75,0.95); font-weight:900">Saved:</span> ${escapeHtml(res.Assessment_ID || '')}`;
          } else {
            out.textContent = 'Save failed (bad response).';
          }
        })
        .withFailureHandler(err => {
          out.textContent = 'Save error: ' + (err?.message || err);
        })
        .saveCPOSLiteAssessment(payload);
    }

    // ---------------------------
    // Init
    // ---------------------------
    async function init() {
      console.log('[CPOS-Lite] init() start');
      setStatus(true, 'Loading CPOS_Lite tables…');

      try {
        const res = await getCPOSLiteTables();
        if (!res || res.ok === false) {
          setStatus(false, 'Failed to load CPOS_Lite tables (bad response).');
          return;
        }

        CPOSL.data.bounds = res.bounds || [];
        CPOSL.data.desirability = res.desirability || [];
        CPOSL.data.weights = res.weights || [];

        buildIndexes_();

        const nFactors = CPOSL.idx.boundsByVar.size;

        try {
          const qRes = await getCPOSQuestionnaireConfig();
          if (qRes && qRes.ok !== false) {
            CPOSL.q.bank = qRes.bank || [];
            CPOSL.q.options = qRes.options || [];
            CPOSL.q.derivationRules = qRes.derivationRules || [];
            CPOSL.q.routingRules = qRes.routingRules || [];
            CPOSL.q.signalToLiteMap = qRes.signalToLiteMap || [];
            CPOSL.q.liteBounds = qRes.liteBounds || [];

            buildQuestionnaireIndexes_();

            const nQ = CPOSL.q.idx.qBankById.size;
            setStatus(true, `Ready • Factors=${nFactors} • QBank=${nQ}`);
          } else {
            console.warn('[CPOS][Q] Failed to load questionnaire config');
            setStatus(true, `Ready • Factors=${nFactors} • Questionnaire unavailable`);
            document.getElementById('qQuestionText').textContent = 'Questionnaire config not available.';
            document.getElementById('btnQStart').disabled = true;
          }
        } catch (qErr) {
          console.warn('[CPOS][Q] Load error:', qErr);
          setStatus(true, `Ready • Factors=${nFactors} • Questionnaire unavailable`);
          document.getElementById('qQuestionText').textContent = 'Questionnaire config load failed.';
          document.getElementById('btnQStart').disabled = true;
        }

        renderFactorForm();
        updateQuestionnaireUIState_();
      } catch (err) {
        console.error('[CPOS-Lite] load error:', err);
        setStatus(false, 'Load error: ' + (err?.message || String(err)));
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
  init();
  
  // ✅ NEW: Language selector event listeners
  const langEN = document.getElementById('langEN');
  const langHI = document.getElementById('langHI');
  
  if (langEN) {
    langEN.addEventListener('change', function() {
      if (this.checked) {
        CPOSL.language = 'EN';
        if (CPOSL.qState.current) {
          renderQuestionUI_();
        }
        updateQuestionnaireUIState_();
        setStatus(true, 'Language changed to English');
      }
    });
  }
  
  if (langHI) {
    langHI.addEventListener('change', function() {
      if (this.checked) {
        CPOSL.language = 'HI';
        if (CPOSL.qState.current) {
          renderQuestionUI_();
        }
        updateQuestionnaireUIState_();
        setStatus(true, 'भाषा हिन्दी में बदल गई');
      }
    });
  }
});
  </script>

</body>

</html>
